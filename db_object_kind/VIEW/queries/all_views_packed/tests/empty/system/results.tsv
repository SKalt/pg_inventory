schema_name	name	tablespace_name	owner	acl	description	info	kind	approximate_number_of_rows	partition_bound	n_pages	n_pages_all_visible	n_user_columns	n_check_constraints	view_definition
information_schema	_pg_foreign_data_wrappers		postgres			3328	v	-1		0	0	7	0	" SELECT w.oid,\n    w.fdwowner,\n    w.fdwoptions,\n    current_database()::information_schema.sql_identifier AS foreign_data_wrapper_catalog,\n    w.fdwname::information_schema.sql_identifier AS foreign_data_wrapper_name,\n    u.rolname::information_schema.sql_identifier AS authorization_identifier,\n    'c'::character varying::information_schema.character_data AS foreign_data_wrapper_language\n   FROM pg_foreign_data_wrapper w,\n    pg_authid u\n  WHERE u.oid = w.fdwowner AND (pg_has_role(w.fdwowner, 'USAGE'::text) OR has_foreign_data_wrapper_privilege(w.oid, 'USAGE'::text));"
information_schema	_pg_foreign_servers		postgres			3328	v	-1		0	0	9	0	" SELECT s.oid,\n    s.srvoptions,\n    current_database()::information_schema.sql_identifier AS foreign_server_catalog,\n    s.srvname::information_schema.sql_identifier AS foreign_server_name,\n    current_database()::information_schema.sql_identifier AS foreign_data_wrapper_catalog,\n    w.fdwname::information_schema.sql_identifier AS foreign_data_wrapper_name,\n    s.srvtype::information_schema.character_data AS foreign_server_type,\n    s.srvversion::information_schema.character_data AS foreign_server_version,\n    u.rolname::information_schema.sql_identifier AS authorization_identifier\n   FROM pg_foreign_server s,\n    pg_foreign_data_wrapper w,\n    pg_authid u\n  WHERE w.oid = s.srvfdw AND u.oid = s.srvowner AND (pg_has_role(s.srvowner, 'USAGE'::text) OR has_server_privilege(s.oid, 'USAGE'::text));"
information_schema	_pg_foreign_table_columns		postgres			3328	v	-1		0	0	4	0	" SELECT n.nspname,\n    c.relname,\n    a.attname,\n    a.attfdwoptions\n   FROM pg_foreign_table t,\n    pg_authid u,\n    pg_namespace n,\n    pg_class c,\n    pg_attribute a\n  WHERE u.oid = c.relowner AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_column_privilege(c.oid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text)) AND n.oid = c.relnamespace AND c.oid = t.ftrelid AND c.relkind = 'f'::""char"" AND a.attrelid = c.oid AND a.attnum > 0;"
information_schema	_pg_foreign_tables		postgres			3328	v	-1		0	0	7	0	" SELECT current_database()::information_schema.sql_identifier AS foreign_table_catalog,\n    n.nspname::information_schema.sql_identifier AS foreign_table_schema,\n    c.relname::information_schema.sql_identifier AS foreign_table_name,\n    t.ftoptions,\n    current_database()::information_schema.sql_identifier AS foreign_server_catalog,\n    s.srvname::information_schema.sql_identifier AS foreign_server_name,\n    u.rolname::information_schema.sql_identifier AS authorization_identifier\n   FROM pg_foreign_table t,\n    pg_foreign_server s,\n    pg_foreign_data_wrapper w,\n    pg_authid u,\n    pg_namespace n,\n    pg_class c\n  WHERE w.oid = s.srvfdw AND u.oid = c.relowner AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text)) AND n.oid = c.relnamespace AND c.oid = t.ftrelid AND c.relkind = 'f'::""char"" AND s.oid = t.ftserver;"
information_schema	_pg_user_mappings		postgres			3328	v	-1		0	0	7	0	" SELECT um.oid,\n    um.umoptions,\n    um.umuser,\n    COALESCE(u.rolname, 'PUBLIC'::name)::information_schema.sql_identifier AS authorization_identifier,\n    s.foreign_server_catalog,\n    s.foreign_server_name,\n    s.authorization_identifier AS srvowner\n   FROM pg_user_mapping um\n     LEFT JOIN pg_authid u ON u.oid = um.umuser,\n    information_schema._pg_foreign_servers s\n  WHERE s.oid = um.umserver;"
information_schema	administrable_role_authorizations		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	3	0	" SELECT applicable_roles.grantee,\n    applicable_roles.role_name,\n    applicable_roles.is_grantable\n   FROM information_schema.applicable_roles\n  WHERE applicable_roles.is_grantable::text = 'YES'::text;"
information_schema	applicable_roles		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	3	0	" SELECT a.rolname::information_schema.sql_identifier AS grantee,\n    b.rolname::information_schema.sql_identifier AS role_name,\n        CASE\n            WHEN m.admin_option THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_grantable\n   FROM ( SELECT pg_auth_members.member,\n            pg_auth_members.roleid,\n            pg_auth_members.admin_option\n           FROM pg_auth_members\n        UNION\n         SELECT pg_database.datdba,\n            pg_authid.oid,\n            false AS bool\n           FROM pg_database,\n            pg_authid\n          WHERE pg_database.datname = current_database() AND pg_authid.rolname = 'pg_database_owner'::name) m\n     JOIN pg_authid a ON m.member = a.oid\n     JOIN pg_authid b ON m.roleid = b.oid\n  WHERE pg_has_role(a.oid, 'USAGE'::text);"
information_schema	attributes		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	31	0	" SELECT current_database()::information_schema.sql_identifier AS udt_catalog,\n    nc.nspname::information_schema.sql_identifier AS udt_schema,\n    c.relname::information_schema.sql_identifier AS udt_name,\n    a.attname::information_schema.sql_identifier AS attribute_name,\n    a.attnum::information_schema.cardinal_number AS ordinal_position,\n    pg_get_expr(ad.adbin, ad.adrelid)::information_schema.character_data AS attribute_default,\n        CASE\n            WHEN a.attnotnull OR t.typtype = 'd'::""char"" AND t.typnotnull THEN 'NO'::text\n            ELSE 'YES'::text\n        END::information_schema.yes_or_no AS is_nullable,\n        CASE\n            WHEN t.typelem <> 0::oid AND t.typlen = '-1'::integer THEN 'ARRAY'::text\n            WHEN nt.nspname = 'pg_catalog'::name THEN format_type(a.atttypid, NULL::integer)\n            ELSE 'USER-DEFINED'::text\n        END::information_schema.character_data AS data_type,\n    information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS character_maximum_length,\n    information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS character_octet_length,\n    NULL::name::information_schema.sql_identifier AS character_set_catalog,\n    NULL::name::information_schema.sql_identifier AS character_set_schema,\n    NULL::name::information_schema.sql_identifier AS character_set_name,\n        CASE\n            WHEN nco.nspname IS NOT NULL THEN current_database()\n            ELSE NULL::name\n        END::information_schema.sql_identifier AS collation_catalog,\n    nco.nspname::information_schema.sql_identifier AS collation_schema,\n    co.collname::information_schema.sql_identifier AS collation_name,\n    information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS numeric_precision,\n    information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS numeric_precision_radix,\n    information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS numeric_scale,\n    information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS datetime_precision,\n    information_schema._pg_interval_type(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.character_data AS interval_type,\n    NULL::integer::information_schema.cardinal_number AS interval_precision,\n    current_database()::information_schema.sql_identifier AS attribute_udt_catalog,\n    nt.nspname::information_schema.sql_identifier AS attribute_udt_schema,\n    t.typname::information_schema.sql_identifier AS attribute_udt_name,\n    NULL::name::information_schema.sql_identifier AS scope_catalog,\n    NULL::name::information_schema.sql_identifier AS scope_schema,\n    NULL::name::information_schema.sql_identifier AS scope_name,\n    NULL::integer::information_schema.cardinal_number AS maximum_cardinality,\n    a.attnum::information_schema.sql_identifier AS dtd_identifier,\n    'NO'::character varying::information_schema.yes_or_no AS is_derived_reference_attribute\n   FROM pg_attribute a\n     LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n     JOIN (pg_class c\n     JOIN pg_namespace nc ON c.relnamespace = nc.oid) ON a.attrelid = c.oid\n     JOIN (pg_type t\n     JOIN pg_namespace nt ON t.typnamespace = nt.oid) ON a.atttypid = t.oid\n     LEFT JOIN (pg_collation co\n     JOIN pg_namespace nco ON co.collnamespace = nco.oid) ON a.attcollation = co.oid AND (nco.nspname <> 'pg_catalog'::name OR co.collname <> 'default'::name)\n  WHERE a.attnum > 0 AND NOT a.attisdropped AND c.relkind = 'c'::""char"" AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_type_privilege(c.reltype, 'USAGE'::text));"
information_schema	character_sets		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	8	0	" SELECT NULL::name::information_schema.sql_identifier AS character_set_catalog,\n    NULL::name::information_schema.sql_identifier AS character_set_schema,\n    getdatabaseencoding()::information_schema.sql_identifier AS character_set_name,\n        CASE\n            WHEN getdatabaseencoding() = 'UTF8'::name THEN 'UCS'::name\n            ELSE getdatabaseencoding()\n        END::information_schema.sql_identifier AS character_repertoire,\n    getdatabaseencoding()::information_schema.sql_identifier AS form_of_use,\n    current_database()::information_schema.sql_identifier AS default_collate_catalog,\n    nc.nspname::information_schema.sql_identifier AS default_collate_schema,\n    c.collname::information_schema.sql_identifier AS default_collate_name\n   FROM pg_database d\n     LEFT JOIN (pg_collation c\n     JOIN pg_namespace nc ON c.collnamespace = nc.oid) ON d.datcollate = c.collcollate AND d.datctype = c.collctype\n  WHERE d.datname = current_database()\n  ORDER BY (char_length(c.collname::text)) DESC, c.collname\n LIMIT 1;"
information_schema	check_constraint_routine_usage		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	6	0	" SELECT DISTINCT current_database()::information_schema.sql_identifier AS constraint_catalog,\n    nc.nspname::information_schema.sql_identifier AS constraint_schema,\n    c.conname::information_schema.sql_identifier AS constraint_name,\n    current_database()::information_schema.sql_identifier AS specific_catalog,\n    np.nspname::information_schema.sql_identifier AS specific_schema,\n    nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name\n   FROM pg_namespace nc,\n    pg_constraint c,\n    pg_depend d,\n    pg_proc p,\n    pg_namespace np\n  WHERE nc.oid = c.connamespace AND c.contype = 'c'::""char"" AND c.oid = d.objid AND d.classid = 'pg_constraint'::regclass::oid AND d.refobjid = p.oid AND d.refclassid = 'pg_proc'::regclass::oid AND p.pronamespace = np.oid AND pg_has_role(p.proowner, 'USAGE'::text);"
information_schema	check_constraints		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	4	0	" SELECT current_database()::information_schema.sql_identifier AS constraint_catalog,\n    rs.nspname::information_schema.sql_identifier AS constraint_schema,\n    con.conname::information_schema.sql_identifier AS constraint_name,\n    SUBSTRING(pg_get_constraintdef(con.oid) FROM 7)::information_schema.character_data AS check_clause\n   FROM pg_constraint con\n     LEFT JOIN pg_namespace rs ON rs.oid = con.connamespace\n     LEFT JOIN pg_class c ON c.oid = con.conrelid\n     LEFT JOIN pg_type t ON t.oid = con.contypid\n  WHERE pg_has_role(COALESCE(c.relowner, t.typowner), 'USAGE'::text) AND con.contype = 'c'::""char""\nUNION\n SELECT current_database()::information_schema.sql_identifier AS constraint_catalog,\n    n.nspname::information_schema.sql_identifier AS constraint_schema,\n    (((((n.oid::text || '_'::text) || r.oid::text) || '_'::text) || a.attnum::text) || '_not_null'::text)::information_schema.sql_identifier AS constraint_name,\n    (a.attname::text || ' IS NOT NULL'::text)::information_schema.character_data AS check_clause\n   FROM pg_namespace n,\n    pg_class r,\n    pg_attribute a\n  WHERE n.oid = r.relnamespace AND r.oid = a.attrelid AND a.attnum > 0 AND NOT a.attisdropped AND a.attnotnull AND (r.relkind = ANY (ARRAY['r'::""char"", 'p'::""char""])) AND pg_has_role(r.relowner, 'USAGE'::text);"
information_schema	collation_character_set_applicability		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	6	0	" SELECT current_database()::information_schema.sql_identifier AS collation_catalog,\n    nc.nspname::information_schema.sql_identifier AS collation_schema,\n    c.collname::information_schema.sql_identifier AS collation_name,\n    NULL::name::information_schema.sql_identifier AS character_set_catalog,\n    NULL::name::information_schema.sql_identifier AS character_set_schema,\n    getdatabaseencoding()::information_schema.sql_identifier AS character_set_name\n   FROM pg_collation c,\n    pg_namespace nc\n  WHERE c.collnamespace = nc.oid AND (c.collencoding = ANY (ARRAY['-1'::integer, ( SELECT pg_database.encoding\n           FROM pg_database\n          WHERE pg_database.datname = current_database())]));"
information_schema	collations		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	4	0	" SELECT current_database()::information_schema.sql_identifier AS collation_catalog,\n    nc.nspname::information_schema.sql_identifier AS collation_schema,\n    c.collname::information_schema.sql_identifier AS collation_name,\n    'NO PAD'::character varying::information_schema.character_data AS pad_attribute\n   FROM pg_collation c,\n    pg_namespace nc\n  WHERE c.collnamespace = nc.oid AND (c.collencoding = ANY (ARRAY['-1'::integer, ( SELECT pg_database.encoding\n           FROM pg_database\n          WHERE pg_database.datname = current_database())]));"
information_schema	column_column_usage		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	5	0	" SELECT DISTINCT current_database()::information_schema.sql_identifier AS table_catalog,\n    n.nspname::information_schema.sql_identifier AS table_schema,\n    c.relname::information_schema.sql_identifier AS table_name,\n    ac.attname::information_schema.sql_identifier AS column_name,\n    ad.attname::information_schema.sql_identifier AS dependent_column\n   FROM pg_namespace n,\n    pg_class c,\n    pg_depend d,\n    pg_attribute ac,\n    pg_attribute ad\n  WHERE n.oid = c.relnamespace AND c.oid = ac.attrelid AND c.oid = ad.attrelid AND d.classid = 'pg_class'::regclass::oid AND d.refclassid = 'pg_class'::regclass::oid AND d.objid = d.refobjid AND c.oid = d.objid AND d.objsubid = ad.attnum AND d.refobjsubid = ac.attnum AND ad.attgenerated <> ''::""char"" AND pg_has_role(c.relowner, 'USAGE'::text);"
information_schema	column_domain_usage		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	7	0	" SELECT current_database()::information_schema.sql_identifier AS domain_catalog,\n    nt.nspname::information_schema.sql_identifier AS domain_schema,\n    t.typname::information_schema.sql_identifier AS domain_name,\n    current_database()::information_schema.sql_identifier AS table_catalog,\n    nc.nspname::information_schema.sql_identifier AS table_schema,\n    c.relname::information_schema.sql_identifier AS table_name,\n    a.attname::information_schema.sql_identifier AS column_name\n   FROM pg_type t,\n    pg_namespace nt,\n    pg_class c,\n    pg_namespace nc,\n    pg_attribute a\n  WHERE t.typnamespace = nt.oid AND c.relnamespace = nc.oid AND a.attrelid = c.oid AND a.atttypid = t.oid AND t.typtype = 'd'::""char"" AND (c.relkind = ANY (ARRAY['r'::""char"", 'v'::""char"", 'f'::""char"", 'p'::""char""])) AND a.attnum > 0 AND NOT a.attisdropped AND pg_has_role(t.typowner, 'USAGE'::text);"
information_schema	column_options		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	6	0	" SELECT current_database()::information_schema.sql_identifier AS table_catalog,\n    c.nspname::information_schema.sql_identifier AS table_schema,\n    c.relname::information_schema.sql_identifier AS table_name,\n    c.attname::information_schema.sql_identifier AS column_name,\n    (pg_options_to_table(c.attfdwoptions)).option_name::information_schema.sql_identifier AS option_name,\n    (pg_options_to_table(c.attfdwoptions)).option_value::information_schema.character_data AS option_value\n   FROM information_schema._pg_foreign_table_columns c;"
information_schema	column_privileges		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	8	0	" SELECT u_grantor.rolname::information_schema.sql_identifier AS grantor,\n    grantee.rolname::information_schema.sql_identifier AS grantee,\n    current_database()::information_schema.sql_identifier AS table_catalog,\n    nc.nspname::information_schema.sql_identifier AS table_schema,\n    x.relname::information_schema.sql_identifier AS table_name,\n    x.attname::information_schema.sql_identifier AS column_name,\n    x.prtype::information_schema.character_data AS privilege_type,\n        CASE\n            WHEN pg_has_role(x.grantee, x.relowner, 'USAGE'::text) OR x.grantable THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_grantable\n   FROM ( SELECT pr_c.grantor,\n            pr_c.grantee,\n            a.attname,\n            pr_c.relname,\n            pr_c.relnamespace,\n            pr_c.prtype,\n            pr_c.grantable,\n            pr_c.relowner\n           FROM ( SELECT pg_class.oid,\n                    pg_class.relname,\n                    pg_class.relnamespace,\n                    pg_class.relowner,\n                    (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::""char"", pg_class.relowner)))).grantor AS grantor,\n                    (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::""char"", pg_class.relowner)))).grantee AS grantee,\n                    (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::""char"", pg_class.relowner)))).privilege_type AS privilege_type,\n                    (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::""char"", pg_class.relowner)))).is_grantable AS is_grantable\n                   FROM pg_class\n                  WHERE pg_class.relkind = ANY (ARRAY['r'::""char"", 'v'::""char"", 'f'::""char"", 'p'::""char""])) pr_c(oid, relname, relnamespace, relowner, grantor, grantee, prtype, grantable),\n            pg_attribute a\n          WHERE a.attrelid = pr_c.oid AND a.attnum > 0 AND NOT a.attisdropped\n        UNION\n         SELECT pr_a.grantor,\n            pr_a.grantee,\n            pr_a.attname,\n            c.relname,\n            c.relnamespace,\n            pr_a.prtype,\n            pr_a.grantable,\n            c.relowner\n           FROM ( SELECT a.attrelid,\n                    a.attname,\n                    (aclexplode(COALESCE(a.attacl, acldefault('c'::""char"", cc.relowner)))).grantor AS grantor,\n                    (aclexplode(COALESCE(a.attacl, acldefault('c'::""char"", cc.relowner)))).grantee AS grantee,\n                    (aclexplode(COALESCE(a.attacl, acldefault('c'::""char"", cc.relowner)))).privilege_type AS privilege_type,\n                    (aclexplode(COALESCE(a.attacl, acldefault('c'::""char"", cc.relowner)))).is_grantable AS is_grantable\n                   FROM pg_attribute a\n                     JOIN pg_class cc ON a.attrelid = cc.oid\n                  WHERE a.attnum > 0 AND NOT a.attisdropped) pr_a(attrelid, attname, grantor, grantee, prtype, grantable),\n            pg_class c\n          WHERE pr_a.attrelid = c.oid AND (c.relkind = ANY (ARRAY['r'::""char"", 'v'::""char"", 'f'::""char"", 'p'::""char""]))) x,\n    pg_namespace nc,\n    pg_authid u_grantor,\n    ( SELECT pg_authid.oid,\n            pg_authid.rolname\n           FROM pg_authid\n        UNION ALL\n         SELECT 0::oid AS oid,\n            'PUBLIC'::name) grantee(oid, rolname)\n  WHERE x.relnamespace = nc.oid AND x.grantee = grantee.oid AND x.grantor = u_grantor.oid AND (x.prtype = ANY (ARRAY['INSERT'::text, 'SELECT'::text, 'UPDATE'::text, 'REFERENCES'::text])) AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR grantee.rolname = 'PUBLIC'::name);"
information_schema	column_udt_usage		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	7	0	" SELECT current_database()::information_schema.sql_identifier AS udt_catalog,\n    COALESCE(nbt.nspname, nt.nspname)::information_schema.sql_identifier AS udt_schema,\n    COALESCE(bt.typname, t.typname)::information_schema.sql_identifier AS udt_name,\n    current_database()::information_schema.sql_identifier AS table_catalog,\n    nc.nspname::information_schema.sql_identifier AS table_schema,\n    c.relname::information_schema.sql_identifier AS table_name,\n    a.attname::information_schema.sql_identifier AS column_name\n   FROM pg_attribute a,\n    pg_class c,\n    pg_namespace nc,\n    pg_type t\n     JOIN pg_namespace nt ON t.typnamespace = nt.oid\n     LEFT JOIN (pg_type bt\n     JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid) ON t.typtype = 'd'::""char"" AND t.typbasetype = bt.oid\n  WHERE a.attrelid = c.oid AND a.atttypid = t.oid AND nc.oid = c.relnamespace AND a.attnum > 0 AND NOT a.attisdropped AND (c.relkind = ANY (ARRAY['r'::""char"", 'v'::""char"", 'f'::""char"", 'p'::""char""])) AND pg_has_role(COALESCE(bt.typowner, t.typowner), 'USAGE'::text);"
information_schema	columns		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	44	0	" SELECT current_database()::information_schema.sql_identifier AS table_catalog,\n    nc.nspname::information_schema.sql_identifier AS table_schema,\n    c.relname::information_schema.sql_identifier AS table_name,\n    a.attname::information_schema.sql_identifier AS column_name,\n    a.attnum::information_schema.cardinal_number AS ordinal_position,\n        CASE\n            WHEN a.attgenerated = ''::""char"" THEN pg_get_expr(ad.adbin, ad.adrelid)\n            ELSE NULL::text\n        END::information_schema.character_data AS column_default,\n        CASE\n            WHEN a.attnotnull OR t.typtype = 'd'::""char"" AND t.typnotnull THEN 'NO'::text\n            ELSE 'YES'::text\n        END::information_schema.yes_or_no AS is_nullable,\n        CASE\n            WHEN t.typtype = 'd'::""char"" THEN\n            CASE\n                WHEN bt.typelem <> 0::oid AND bt.typlen = '-1'::integer THEN 'ARRAY'::text\n                WHEN nbt.nspname = 'pg_catalog'::name THEN format_type(t.typbasetype, NULL::integer)\n                ELSE 'USER-DEFINED'::text\n            END\n            ELSE\n            CASE\n                WHEN t.typelem <> 0::oid AND t.typlen = '-1'::integer THEN 'ARRAY'::text\n                WHEN nt.nspname = 'pg_catalog'::name THEN format_type(a.atttypid, NULL::integer)\n                ELSE 'USER-DEFINED'::text\n            END\n        END::information_schema.character_data AS data_type,\n    information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS character_maximum_length,\n    information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS character_octet_length,\n    information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS numeric_precision,\n    information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS numeric_precision_radix,\n    information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS numeric_scale,\n    information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS datetime_precision,\n    information_schema._pg_interval_type(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.character_data AS interval_type,\n    NULL::integer::information_schema.cardinal_number AS interval_precision,\n    NULL::name::information_schema.sql_identifier AS character_set_catalog,\n    NULL::name::information_schema.sql_identifier AS character_set_schema,\n    NULL::name::information_schema.sql_identifier AS character_set_name,\n        CASE\n            WHEN nco.nspname IS NOT NULL THEN current_database()\n            ELSE NULL::name\n        END::information_schema.sql_identifier AS collation_catalog,\n    nco.nspname::information_schema.sql_identifier AS collation_schema,\n    co.collname::information_schema.sql_identifier AS collation_name,\n        CASE\n            WHEN t.typtype = 'd'::""char"" THEN current_database()\n            ELSE NULL::name\n        END::information_schema.sql_identifier AS domain_catalog,\n        CASE\n            WHEN t.typtype = 'd'::""char"" THEN nt.nspname\n            ELSE NULL::name\n        END::information_schema.sql_identifier AS domain_schema,\n        CASE\n            WHEN t.typtype = 'd'::""char"" THEN t.typname\n            ELSE NULL::name\n        END::information_schema.sql_identifier AS domain_name,\n    current_database()::information_schema.sql_identifier AS udt_catalog,\n    COALESCE(nbt.nspname, nt.nspname)::information_schema.sql_identifier AS udt_schema,\n    COALESCE(bt.typname, t.typname)::information_schema.sql_identifier AS udt_name,\n    NULL::name::information_schema.sql_identifier AS scope_catalog,\n    NULL::name::information_schema.sql_identifier AS scope_schema,\n    NULL::name::information_schema.sql_identifier AS scope_name,\n    NULL::integer::information_schema.cardinal_number AS maximum_cardinality,\n    a.attnum::information_schema.sql_identifier AS dtd_identifier,\n    'NO'::character varying::information_schema.yes_or_no AS is_self_referencing,\n        CASE\n            WHEN a.attidentity = ANY (ARRAY['a'::""char"", 'd'::""char""]) THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_identity,\n        CASE a.attidentity\n            WHEN 'a'::""char"" THEN 'ALWAYS'::text\n            WHEN 'd'::""char"" THEN 'BY DEFAULT'::text\n            ELSE NULL::text\n        END::information_schema.character_data AS identity_generation,\n    seq.seqstart::information_schema.character_data AS identity_start,\n    seq.seqincrement::information_schema.character_data AS identity_increment,\n    seq.seqmax::information_schema.character_data AS identity_maximum,\n    seq.seqmin::information_schema.character_data AS identity_minimum,\n        CASE\n            WHEN seq.seqcycle THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS identity_cycle,\n        CASE\n            WHEN a.attgenerated <> ''::""char"" THEN 'ALWAYS'::text\n            ELSE 'NEVER'::text\n        END::information_schema.character_data AS is_generated,\n        CASE\n            WHEN a.attgenerated <> ''::""char"" THEN pg_get_expr(ad.adbin, ad.adrelid)\n            ELSE NULL::text\n        END::information_schema.character_data AS generation_expression,\n        CASE\n            WHEN (c.relkind = ANY (ARRAY['r'::""char"", 'p'::""char""])) OR (c.relkind = ANY (ARRAY['v'::""char"", 'f'::""char""])) AND pg_column_is_updatable(c.oid::regclass, a.attnum, false) THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_updatable\n   FROM pg_attribute a\n     LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n     JOIN (pg_class c\n     JOIN pg_namespace nc ON c.relnamespace = nc.oid) ON a.attrelid = c.oid\n     JOIN (pg_type t\n     JOIN pg_namespace nt ON t.typnamespace = nt.oid) ON a.atttypid = t.oid\n     LEFT JOIN (pg_type bt\n     JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid) ON t.typtype = 'd'::""char"" AND t.typbasetype = bt.oid\n     LEFT JOIN (pg_collation co\n     JOIN pg_namespace nco ON co.collnamespace = nco.oid) ON a.attcollation = co.oid AND (nco.nspname <> 'pg_catalog'::name OR co.collname <> 'default'::name)\n     LEFT JOIN (pg_depend dep\n     JOIN pg_sequence seq ON dep.classid = 'pg_class'::regclass::oid AND dep.objid = seq.seqrelid AND dep.deptype = 'i'::""char"") ON dep.refclassid = 'pg_class'::regclass::oid AND dep.refobjid = c.oid AND dep.refobjsubid = a.attnum\n  WHERE NOT pg_is_other_temp_schema(nc.oid) AND a.attnum > 0 AND NOT a.attisdropped AND (c.relkind = ANY (ARRAY['r'::""char"", 'v'::""char"", 'f'::""char"", 'p'::""char""])) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_column_privilege(c.oid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text));"
information_schema	constraint_column_usage		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	7	0	" SELECT current_database()::information_schema.sql_identifier AS table_catalog,\n    x.tblschema::information_schema.sql_identifier AS table_schema,\n    x.tblname::information_schema.sql_identifier AS table_name,\n    x.colname::information_schema.sql_identifier AS column_name,\n    current_database()::information_schema.sql_identifier AS constraint_catalog,\n    x.cstrschema::information_schema.sql_identifier AS constraint_schema,\n    x.cstrname::information_schema.sql_identifier AS constraint_name\n   FROM ( SELECT DISTINCT nr.nspname,\n            r.relname,\n            r.relowner,\n            a.attname,\n            nc.nspname,\n            c.conname\n           FROM pg_namespace nr,\n            pg_class r,\n            pg_attribute a,\n            pg_depend d,\n            pg_namespace nc,\n            pg_constraint c\n          WHERE nr.oid = r.relnamespace AND r.oid = a.attrelid AND d.refclassid = 'pg_class'::regclass::oid AND d.refobjid = r.oid AND d.refobjsubid = a.attnum AND d.classid = 'pg_constraint'::regclass::oid AND d.objid = c.oid AND c.connamespace = nc.oid AND c.contype = 'c'::""char"" AND (r.relkind = ANY (ARRAY['r'::""char"", 'p'::""char""])) AND NOT a.attisdropped\n        UNION ALL\n         SELECT nr.nspname,\n            r.relname,\n            r.relowner,\n            a.attname,\n            nc.nspname,\n            c.conname\n           FROM pg_namespace nr,\n            pg_class r,\n            pg_attribute a,\n            pg_namespace nc,\n            pg_constraint c\n          WHERE nr.oid = r.relnamespace AND r.oid = a.attrelid AND nc.oid = c.connamespace AND r.oid =\n                CASE c.contype\n                    WHEN 'f'::""char"" THEN c.confrelid\n                    ELSE c.conrelid\n                END AND (a.attnum = ANY (\n                CASE c.contype\n                    WHEN 'f'::""char"" THEN c.confkey\n                    ELSE c.conkey\n                END)) AND NOT a.attisdropped AND (c.contype = ANY (ARRAY['p'::""char"", 'u'::""char"", 'f'::""char""])) AND (r.relkind = ANY (ARRAY['r'::""char"", 'p'::""char""]))) x(tblschema, tblname, tblowner, colname, cstrschema, cstrname)\n  WHERE pg_has_role(x.tblowner, 'USAGE'::text);"
information_schema	constraint_table_usage		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	6	0	" SELECT current_database()::information_schema.sql_identifier AS table_catalog,\n    nr.nspname::information_schema.sql_identifier AS table_schema,\n    r.relname::information_schema.sql_identifier AS table_name,\n    current_database()::information_schema.sql_identifier AS constraint_catalog,\n    nc.nspname::information_schema.sql_identifier AS constraint_schema,\n    c.conname::information_schema.sql_identifier AS constraint_name\n   FROM pg_constraint c,\n    pg_namespace nc,\n    pg_class r,\n    pg_namespace nr\n  WHERE c.connamespace = nc.oid AND r.relnamespace = nr.oid AND (c.contype = 'f'::""char"" AND c.confrelid = r.oid OR (c.contype = ANY (ARRAY['p'::""char"", 'u'::""char""])) AND c.conrelid = r.oid) AND (r.relkind = ANY (ARRAY['r'::""char"", 'p'::""char""])) AND pg_has_role(r.relowner, 'USAGE'::text);"
information_schema	data_type_privileges		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	5	0	" SELECT current_database()::information_schema.sql_identifier AS object_catalog,\n    x.objschema AS object_schema,\n    x.objname AS object_name,\n    x.objtype::information_schema.character_data AS object_type,\n    x.objdtdid AS dtd_identifier\n   FROM ( SELECT attributes.udt_schema,\n            attributes.udt_name,\n            'USER-DEFINED TYPE'::text AS text,\n            attributes.dtd_identifier\n           FROM information_schema.attributes\n        UNION ALL\n         SELECT columns.table_schema,\n            columns.table_name,\n            'TABLE'::text AS text,\n            columns.dtd_identifier\n           FROM information_schema.columns\n        UNION ALL\n         SELECT domains.domain_schema,\n            domains.domain_name,\n            'DOMAIN'::text AS text,\n            domains.dtd_identifier\n           FROM information_schema.domains\n        UNION ALL\n         SELECT parameters.specific_schema,\n            parameters.specific_name,\n            'ROUTINE'::text AS text,\n            parameters.dtd_identifier\n           FROM information_schema.parameters\n        UNION ALL\n         SELECT routines.specific_schema,\n            routines.specific_name,\n            'ROUTINE'::text AS text,\n            routines.dtd_identifier\n           FROM information_schema.routines) x(objschema, objname, objtype, objdtdid);"
information_schema	domain_constraints		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	8	0	" SELECT current_database()::information_schema.sql_identifier AS constraint_catalog,\n    rs.nspname::information_schema.sql_identifier AS constraint_schema,\n    con.conname::information_schema.sql_identifier AS constraint_name,\n    current_database()::information_schema.sql_identifier AS domain_catalog,\n    n.nspname::information_schema.sql_identifier AS domain_schema,\n    t.typname::information_schema.sql_identifier AS domain_name,\n        CASE\n            WHEN con.condeferrable THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_deferrable,\n        CASE\n            WHEN con.condeferred THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS initially_deferred\n   FROM pg_namespace rs,\n    pg_namespace n,\n    pg_constraint con,\n    pg_type t\n  WHERE rs.oid = con.connamespace AND n.oid = t.typnamespace AND t.oid = con.contypid AND (pg_has_role(t.typowner, 'USAGE'::text) OR has_type_privilege(t.oid, 'USAGE'::text));"
information_schema	domain_udt_usage		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	6	0	" SELECT current_database()::information_schema.sql_identifier AS udt_catalog,\n    nbt.nspname::information_schema.sql_identifier AS udt_schema,\n    bt.typname::information_schema.sql_identifier AS udt_name,\n    current_database()::information_schema.sql_identifier AS domain_catalog,\n    nt.nspname::information_schema.sql_identifier AS domain_schema,\n    t.typname::information_schema.sql_identifier AS domain_name\n   FROM pg_type t,\n    pg_namespace nt,\n    pg_type bt,\n    pg_namespace nbt\n  WHERE t.typnamespace = nt.oid AND t.typbasetype = bt.oid AND bt.typnamespace = nbt.oid AND t.typtype = 'd'::""char"" AND pg_has_role(bt.typowner, 'USAGE'::text);"
information_schema	domains		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	27	0	" SELECT current_database()::information_schema.sql_identifier AS domain_catalog,\n    nt.nspname::information_schema.sql_identifier AS domain_schema,\n    t.typname::information_schema.sql_identifier AS domain_name,\n        CASE\n            WHEN t.typelem <> 0::oid AND t.typlen = '-1'::integer THEN 'ARRAY'::text\n            WHEN nbt.nspname = 'pg_catalog'::name THEN format_type(t.typbasetype, NULL::integer)\n            ELSE 'USER-DEFINED'::text\n        END::information_schema.character_data AS data_type,\n    information_schema._pg_char_max_length(t.typbasetype, t.typtypmod)::information_schema.cardinal_number AS character_maximum_length,\n    information_schema._pg_char_octet_length(t.typbasetype, t.typtypmod)::information_schema.cardinal_number AS character_octet_length,\n    NULL::name::information_schema.sql_identifier AS character_set_catalog,\n    NULL::name::information_schema.sql_identifier AS character_set_schema,\n    NULL::name::information_schema.sql_identifier AS character_set_name,\n        CASE\n            WHEN nco.nspname IS NOT NULL THEN current_database()\n            ELSE NULL::name\n        END::information_schema.sql_identifier AS collation_catalog,\n    nco.nspname::information_schema.sql_identifier AS collation_schema,\n    co.collname::information_schema.sql_identifier AS collation_name,\n    information_schema._pg_numeric_precision(t.typbasetype, t.typtypmod)::information_schema.cardinal_number AS numeric_precision,\n    information_schema._pg_numeric_precision_radix(t.typbasetype, t.typtypmod)::information_schema.cardinal_number AS numeric_precision_radix,\n    information_schema._pg_numeric_scale(t.typbasetype, t.typtypmod)::information_schema.cardinal_number AS numeric_scale,\n    information_schema._pg_datetime_precision(t.typbasetype, t.typtypmod)::information_schema.cardinal_number AS datetime_precision,\n    information_schema._pg_interval_type(t.typbasetype, t.typtypmod)::information_schema.character_data AS interval_type,\n    NULL::integer::information_schema.cardinal_number AS interval_precision,\n    t.typdefault::information_schema.character_data AS domain_default,\n    current_database()::information_schema.sql_identifier AS udt_catalog,\n    nbt.nspname::information_schema.sql_identifier AS udt_schema,\n    bt.typname::information_schema.sql_identifier AS udt_name,\n    NULL::name::information_schema.sql_identifier AS scope_catalog,\n    NULL::name::information_schema.sql_identifier AS scope_schema,\n    NULL::name::information_schema.sql_identifier AS scope_name,\n    NULL::integer::information_schema.cardinal_number AS maximum_cardinality,\n    1::information_schema.sql_identifier AS dtd_identifier\n   FROM pg_type t\n     JOIN pg_namespace nt ON t.typnamespace = nt.oid\n     JOIN (pg_type bt\n     JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid) ON t.typbasetype = bt.oid AND t.typtype = 'd'::""char""\n     LEFT JOIN (pg_collation co\n     JOIN pg_namespace nco ON co.collnamespace = nco.oid) ON t.typcollation = co.oid AND (nco.nspname <> 'pg_catalog'::name OR co.collname <> 'default'::name)\n  WHERE pg_has_role(t.typowner, 'USAGE'::text) OR has_type_privilege(t.oid, 'USAGE'::text);"
information_schema	element_types		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	29	0	" SELECT current_database()::information_schema.sql_identifier AS object_catalog,\n    n.nspname::information_schema.sql_identifier AS object_schema,\n    x.objname AS object_name,\n    x.objtype::information_schema.character_data AS object_type,\n    x.objdtdid::information_schema.sql_identifier AS collection_type_identifier,\n        CASE\n            WHEN nbt.nspname = 'pg_catalog'::name THEN format_type(bt.oid, NULL::integer)\n            ELSE 'USER-DEFINED'::text\n        END::information_schema.character_data AS data_type,\n    NULL::integer::information_schema.cardinal_number AS character_maximum_length,\n    NULL::integer::information_schema.cardinal_number AS character_octet_length,\n    NULL::name::information_schema.sql_identifier AS character_set_catalog,\n    NULL::name::information_schema.sql_identifier AS character_set_schema,\n    NULL::name::information_schema.sql_identifier AS character_set_name,\n        CASE\n            WHEN nco.nspname IS NOT NULL THEN current_database()\n            ELSE NULL::name\n        END::information_schema.sql_identifier AS collation_catalog,\n    nco.nspname::information_schema.sql_identifier AS collation_schema,\n    co.collname::information_schema.sql_identifier AS collation_name,\n    NULL::integer::information_schema.cardinal_number AS numeric_precision,\n    NULL::integer::information_schema.cardinal_number AS numeric_precision_radix,\n    NULL::integer::information_schema.cardinal_number AS numeric_scale,\n    NULL::integer::information_schema.cardinal_number AS datetime_precision,\n    NULL::character varying::information_schema.character_data AS interval_type,\n    NULL::integer::information_schema.cardinal_number AS interval_precision,\n    NULL::character varying::information_schema.character_data AS domain_default,\n    current_database()::information_schema.sql_identifier AS udt_catalog,\n    nbt.nspname::information_schema.sql_identifier AS udt_schema,\n    bt.typname::information_schema.sql_identifier AS udt_name,\n    NULL::name::information_schema.sql_identifier AS scope_catalog,\n    NULL::name::information_schema.sql_identifier AS scope_schema,\n    NULL::name::information_schema.sql_identifier AS scope_name,\n    NULL::integer::information_schema.cardinal_number AS maximum_cardinality,\n    ('a'::text || x.objdtdid::text)::information_schema.sql_identifier AS dtd_identifier\n   FROM pg_namespace n,\n    pg_type at,\n    pg_namespace nbt,\n    pg_type bt,\n    ( SELECT c.relnamespace,\n            c.relname::information_schema.sql_identifier AS relname,\n                CASE\n                    WHEN c.relkind = 'c'::""char"" THEN 'USER-DEFINED TYPE'::text\n                    ELSE 'TABLE'::text\n                END AS ""case"",\n            a.attnum,\n            a.atttypid,\n            a.attcollation\n           FROM pg_class c,\n            pg_attribute a\n          WHERE c.oid = a.attrelid AND (c.relkind = ANY (ARRAY['r'::""char"", 'v'::""char"", 'f'::""char"", 'c'::""char"", 'p'::""char""])) AND a.attnum > 0 AND NOT a.attisdropped\n        UNION ALL\n         SELECT t.typnamespace,\n            t.typname::information_schema.sql_identifier AS typname,\n            'DOMAIN'::text AS text,\n            1,\n            t.typbasetype,\n            t.typcollation\n           FROM pg_type t\n          WHERE t.typtype = 'd'::""char""\n        UNION ALL\n         SELECT ss.pronamespace,\n            nameconcatoid(ss.proname, ss.oid)::information_schema.sql_identifier AS nameconcatoid,\n            'ROUTINE'::text AS text,\n            (ss.x).n AS n,\n            (ss.x).x AS x,\n            0\n           FROM ( SELECT p.pronamespace,\n                    p.proname,\n                    p.oid,\n                    information_schema._pg_expandarray(COALESCE(p.proallargtypes, p.proargtypes::oid[])) AS x\n                   FROM pg_proc p) ss\n        UNION ALL\n         SELECT p.pronamespace,\n            nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS nameconcatoid,\n            'ROUTINE'::text AS text,\n            0,\n            p.prorettype,\n            0\n           FROM pg_proc p) x(objschema, objname, objtype, objdtdid, objtypeid, objcollation)\n     LEFT JOIN (pg_collation co\n     JOIN pg_namespace nco ON co.collnamespace = nco.oid) ON x.objcollation = co.oid AND (nco.nspname <> 'pg_catalog'::name OR co.collname <> 'default'::name)\n  WHERE n.oid = x.objschema AND at.oid = x.objtypeid AND at.typelem <> 0::oid AND at.typlen = '-1'::integer AND at.typelem = bt.oid AND nbt.oid = bt.typnamespace AND ((n.nspname, x.objname::name, x.objtype, x.objdtdid::information_schema.sql_identifier::name) IN ( SELECT data_type_privileges.object_schema,\n            data_type_privileges.object_name,\n            data_type_privileges.object_type,\n            data_type_privileges.dtd_identifier\n           FROM information_schema.data_type_privileges));"
information_schema	enabled_roles		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	1	0	" SELECT a.rolname::information_schema.sql_identifier AS role_name\n   FROM pg_authid a\n  WHERE pg_has_role(a.oid, 'USAGE'::text);"
information_schema	foreign_data_wrapper_options		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	4	0	" SELECT w.foreign_data_wrapper_catalog,\n    w.foreign_data_wrapper_name,\n    (pg_options_to_table(w.fdwoptions)).option_name::information_schema.sql_identifier AS option_name,\n    (pg_options_to_table(w.fdwoptions)).option_value::information_schema.character_data AS option_value\n   FROM information_schema._pg_foreign_data_wrappers w;"
information_schema	foreign_data_wrappers		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	5	0	" SELECT w.foreign_data_wrapper_catalog,\n    w.foreign_data_wrapper_name,\n    w.authorization_identifier,\n    NULL::character varying::information_schema.character_data AS library_name,\n    w.foreign_data_wrapper_language\n   FROM information_schema._pg_foreign_data_wrappers w;"
information_schema	foreign_server_options		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	4	0	" SELECT s.foreign_server_catalog,\n    s.foreign_server_name,\n    (pg_options_to_table(s.srvoptions)).option_name::information_schema.sql_identifier AS option_name,\n    (pg_options_to_table(s.srvoptions)).option_value::information_schema.character_data AS option_value\n   FROM information_schema._pg_foreign_servers s;"
information_schema	foreign_servers		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	7	0	" SELECT _pg_foreign_servers.foreign_server_catalog,\n    _pg_foreign_servers.foreign_server_name,\n    _pg_foreign_servers.foreign_data_wrapper_catalog,\n    _pg_foreign_servers.foreign_data_wrapper_name,\n    _pg_foreign_servers.foreign_server_type,\n    _pg_foreign_servers.foreign_server_version,\n    _pg_foreign_servers.authorization_identifier\n   FROM information_schema._pg_foreign_servers;"
information_schema	foreign_table_options		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	5	0	" SELECT t.foreign_table_catalog,\n    t.foreign_table_schema,\n    t.foreign_table_name,\n    (pg_options_to_table(t.ftoptions)).option_name::information_schema.sql_identifier AS option_name,\n    (pg_options_to_table(t.ftoptions)).option_value::information_schema.character_data AS option_value\n   FROM information_schema._pg_foreign_tables t;"
information_schema	foreign_tables		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	5	0	" SELECT _pg_foreign_tables.foreign_table_catalog,\n    _pg_foreign_tables.foreign_table_schema,\n    _pg_foreign_tables.foreign_table_name,\n    _pg_foreign_tables.foreign_server_catalog,\n    _pg_foreign_tables.foreign_server_name\n   FROM information_schema._pg_foreign_tables;"
information_schema	information_schema_catalog_name		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	1	0	" SELECT current_database()::information_schema.sql_identifier AS catalog_name;"
information_schema	key_column_usage		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	9	0	" SELECT current_database()::information_schema.sql_identifier AS constraint_catalog,\n    ss.nc_nspname::information_schema.sql_identifier AS constraint_schema,\n    ss.conname::information_schema.sql_identifier AS constraint_name,\n    current_database()::information_schema.sql_identifier AS table_catalog,\n    ss.nr_nspname::information_schema.sql_identifier AS table_schema,\n    ss.relname::information_schema.sql_identifier AS table_name,\n    a.attname::information_schema.sql_identifier AS column_name,\n    (ss.x).n::information_schema.cardinal_number AS ordinal_position,\n        CASE\n            WHEN ss.contype = 'f'::""char"" THEN information_schema._pg_index_position(ss.conindid, ss.confkey[(ss.x).n])\n            ELSE NULL::integer\n        END::information_schema.cardinal_number AS position_in_unique_constraint\n   FROM pg_attribute a,\n    ( SELECT r.oid AS roid,\n            r.relname,\n            r.relowner,\n            nc.nspname AS nc_nspname,\n            nr.nspname AS nr_nspname,\n            c.oid AS coid,\n            c.conname,\n            c.contype,\n            c.conindid,\n            c.confkey,\n            c.confrelid,\n            information_schema._pg_expandarray(c.conkey) AS x\n           FROM pg_namespace nr,\n            pg_class r,\n            pg_namespace nc,\n            pg_constraint c\n          WHERE nr.oid = r.relnamespace AND r.oid = c.conrelid AND nc.oid = c.connamespace AND (c.contype = ANY (ARRAY['p'::""char"", 'u'::""char"", 'f'::""char""])) AND (r.relkind = ANY (ARRAY['r'::""char"", 'p'::""char""])) AND NOT pg_is_other_temp_schema(nr.oid)) ss\n  WHERE ss.roid = a.attrelid AND a.attnum = (ss.x).x AND NOT a.attisdropped AND (pg_has_role(ss.relowner, 'USAGE'::text) OR has_column_privilege(ss.roid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text));"
information_schema	parameters		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	32	0	" SELECT current_database()::information_schema.sql_identifier AS specific_catalog,\n    ss.n_nspname::information_schema.sql_identifier AS specific_schema,\n    nameconcatoid(ss.proname, ss.p_oid)::information_schema.sql_identifier AS specific_name,\n    (ss.x).n::information_schema.cardinal_number AS ordinal_position,\n        CASE\n            WHEN ss.proargmodes IS NULL THEN 'IN'::text\n            WHEN ss.proargmodes[(ss.x).n] = 'i'::""char"" THEN 'IN'::text\n            WHEN ss.proargmodes[(ss.x).n] = 'o'::""char"" THEN 'OUT'::text\n            WHEN ss.proargmodes[(ss.x).n] = 'b'::""char"" THEN 'INOUT'::text\n            WHEN ss.proargmodes[(ss.x).n] = 'v'::""char"" THEN 'IN'::text\n            WHEN ss.proargmodes[(ss.x).n] = 't'::""char"" THEN 'OUT'::text\n            ELSE NULL::text\n        END::information_schema.character_data AS parameter_mode,\n    'NO'::character varying::information_schema.yes_or_no AS is_result,\n    'NO'::character varying::information_schema.yes_or_no AS as_locator,\n    NULLIF(ss.proargnames[(ss.x).n], ''::text)::information_schema.sql_identifier AS parameter_name,\n        CASE\n            WHEN t.typelem <> 0::oid AND t.typlen = '-1'::integer THEN 'ARRAY'::text\n            WHEN nt.nspname = 'pg_catalog'::name THEN format_type(t.oid, NULL::integer)\n            ELSE 'USER-DEFINED'::text\n        END::information_schema.character_data AS data_type,\n    NULL::integer::information_schema.cardinal_number AS character_maximum_length,\n    NULL::integer::information_schema.cardinal_number AS character_octet_length,\n    NULL::name::information_schema.sql_identifier AS character_set_catalog,\n    NULL::name::information_schema.sql_identifier AS character_set_schema,\n    NULL::name::information_schema.sql_identifier AS character_set_name,\n    NULL::name::information_schema.sql_identifier AS collation_catalog,\n    NULL::name::information_schema.sql_identifier AS collation_schema,\n    NULL::name::information_schema.sql_identifier AS collation_name,\n    NULL::integer::information_schema.cardinal_number AS numeric_precision,\n    NULL::integer::information_schema.cardinal_number AS numeric_precision_radix,\n    NULL::integer::information_schema.cardinal_number AS numeric_scale,\n    NULL::integer::information_schema.cardinal_number AS datetime_precision,\n    NULL::character varying::information_schema.character_data AS interval_type,\n    NULL::integer::information_schema.cardinal_number AS interval_precision,\n    current_database()::information_schema.sql_identifier AS udt_catalog,\n    nt.nspname::information_schema.sql_identifier AS udt_schema,\n    t.typname::information_schema.sql_identifier AS udt_name,\n    NULL::name::information_schema.sql_identifier AS scope_catalog,\n    NULL::name::information_schema.sql_identifier AS scope_schema,\n    NULL::name::information_schema.sql_identifier AS scope_name,\n    NULL::integer::information_schema.cardinal_number AS maximum_cardinality,\n    (ss.x).n::information_schema.sql_identifier AS dtd_identifier,\n        CASE\n            WHEN pg_has_role(ss.proowner, 'USAGE'::text) THEN pg_get_function_arg_default(ss.p_oid, (ss.x).n)\n            ELSE NULL::text\n        END::information_schema.character_data AS parameter_default\n   FROM pg_type t,\n    pg_namespace nt,\n    ( SELECT n.nspname AS n_nspname,\n            p.proname,\n            p.oid AS p_oid,\n            p.proowner,\n            p.proargnames,\n            p.proargmodes,\n            information_schema._pg_expandarray(COALESCE(p.proallargtypes, p.proargtypes::oid[])) AS x\n           FROM pg_namespace n,\n            pg_proc p\n          WHERE n.oid = p.pronamespace AND (pg_has_role(p.proowner, 'USAGE'::text) OR has_function_privilege(p.oid, 'EXECUTE'::text))) ss\n  WHERE t.oid = (ss.x).x AND t.typnamespace = nt.oid;"
information_schema	referential_constraints		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	9	0	" SELECT current_database()::information_schema.sql_identifier AS constraint_catalog,\n    ncon.nspname::information_schema.sql_identifier AS constraint_schema,\n    con.conname::information_schema.sql_identifier AS constraint_name,\n        CASE\n            WHEN npkc.nspname IS NULL THEN NULL::name\n            ELSE current_database()\n        END::information_schema.sql_identifier AS unique_constraint_catalog,\n    npkc.nspname::information_schema.sql_identifier AS unique_constraint_schema,\n    pkc.conname::information_schema.sql_identifier AS unique_constraint_name,\n        CASE con.confmatchtype\n            WHEN 'f'::""char"" THEN 'FULL'::text\n            WHEN 'p'::""char"" THEN 'PARTIAL'::text\n            WHEN 's'::""char"" THEN 'NONE'::text\n            ELSE NULL::text\n        END::information_schema.character_data AS match_option,\n        CASE con.confupdtype\n            WHEN 'c'::""char"" THEN 'CASCADE'::text\n            WHEN 'n'::""char"" THEN 'SET NULL'::text\n            WHEN 'd'::""char"" THEN 'SET DEFAULT'::text\n            WHEN 'r'::""char"" THEN 'RESTRICT'::text\n            WHEN 'a'::""char"" THEN 'NO ACTION'::text\n            ELSE NULL::text\n        END::information_schema.character_data AS update_rule,\n        CASE con.confdeltype\n            WHEN 'c'::""char"" THEN 'CASCADE'::text\n            WHEN 'n'::""char"" THEN 'SET NULL'::text\n            WHEN 'd'::""char"" THEN 'SET DEFAULT'::text\n            WHEN 'r'::""char"" THEN 'RESTRICT'::text\n            WHEN 'a'::""char"" THEN 'NO ACTION'::text\n            ELSE NULL::text\n        END::information_schema.character_data AS delete_rule\n   FROM pg_namespace ncon\n     JOIN pg_constraint con ON ncon.oid = con.connamespace\n     JOIN pg_class c ON con.conrelid = c.oid AND con.contype = 'f'::""char""\n     LEFT JOIN pg_depend d1 ON d1.objid = con.oid AND d1.classid = 'pg_constraint'::regclass::oid AND d1.refclassid = 'pg_class'::regclass::oid AND d1.refobjsubid = 0\n     LEFT JOIN pg_depend d2 ON d2.refclassid = 'pg_constraint'::regclass::oid AND d2.classid = 'pg_class'::regclass::oid AND d2.objid = d1.refobjid AND d2.objsubid = 0 AND d2.deptype = 'i'::""char""\n     LEFT JOIN pg_constraint pkc ON pkc.oid = d2.refobjid AND (pkc.contype = ANY (ARRAY['p'::""char"", 'u'::""char""])) AND pkc.conrelid = con.confrelid\n     LEFT JOIN pg_namespace npkc ON pkc.connamespace = npkc.oid\n  WHERE pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES'::text);"
information_schema	role_column_grants		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	8	0	" SELECT column_privileges.grantor,\n    column_privileges.grantee,\n    column_privileges.table_catalog,\n    column_privileges.table_schema,\n    column_privileges.table_name,\n    column_privileges.column_name,\n    column_privileges.privilege_type,\n    column_privileges.is_grantable\n   FROM information_schema.column_privileges\n  WHERE (column_privileges.grantor::name IN ( SELECT enabled_roles.role_name\n           FROM information_schema.enabled_roles)) OR (column_privileges.grantee::name IN ( SELECT enabled_roles.role_name\n           FROM information_schema.enabled_roles));"
information_schema	role_routine_grants		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	10	0	" SELECT routine_privileges.grantor,\n    routine_privileges.grantee,\n    routine_privileges.specific_catalog,\n    routine_privileges.specific_schema,\n    routine_privileges.specific_name,\n    routine_privileges.routine_catalog,\n    routine_privileges.routine_schema,\n    routine_privileges.routine_name,\n    routine_privileges.privilege_type,\n    routine_privileges.is_grantable\n   FROM information_schema.routine_privileges\n  WHERE (routine_privileges.grantor::name IN ( SELECT enabled_roles.role_name\n           FROM information_schema.enabled_roles)) OR (routine_privileges.grantee::name IN ( SELECT enabled_roles.role_name\n           FROM information_schema.enabled_roles));"
information_schema	role_table_grants		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	8	0	" SELECT table_privileges.grantor,\n    table_privileges.grantee,\n    table_privileges.table_catalog,\n    table_privileges.table_schema,\n    table_privileges.table_name,\n    table_privileges.privilege_type,\n    table_privileges.is_grantable,\n    table_privileges.with_hierarchy\n   FROM information_schema.table_privileges\n  WHERE (table_privileges.grantor::name IN ( SELECT enabled_roles.role_name\n           FROM information_schema.enabled_roles)) OR (table_privileges.grantee::name IN ( SELECT enabled_roles.role_name\n           FROM information_schema.enabled_roles));"
information_schema	role_udt_grants		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	7	0	" SELECT udt_privileges.grantor,\n    udt_privileges.grantee,\n    udt_privileges.udt_catalog,\n    udt_privileges.udt_schema,\n    udt_privileges.udt_name,\n    udt_privileges.privilege_type,\n    udt_privileges.is_grantable\n   FROM information_schema.udt_privileges\n  WHERE (udt_privileges.grantor::name IN ( SELECT enabled_roles.role_name\n           FROM information_schema.enabled_roles)) OR (udt_privileges.grantee::name IN ( SELECT enabled_roles.role_name\n           FROM information_schema.enabled_roles));"
information_schema	role_usage_grants		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	8	0	" SELECT usage_privileges.grantor,\n    usage_privileges.grantee,\n    usage_privileges.object_catalog,\n    usage_privileges.object_schema,\n    usage_privileges.object_name,\n    usage_privileges.object_type,\n    usage_privileges.privilege_type,\n    usage_privileges.is_grantable\n   FROM information_schema.usage_privileges\n  WHERE (usage_privileges.grantor::name IN ( SELECT enabled_roles.role_name\n           FROM information_schema.enabled_roles)) OR (usage_privileges.grantee::name IN ( SELECT enabled_roles.role_name\n           FROM information_schema.enabled_roles));"
information_schema	routine_column_usage		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	10	0	" SELECT DISTINCT current_database()::information_schema.sql_identifier AS specific_catalog,\n    np.nspname::information_schema.sql_identifier AS specific_schema,\n    nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,\n    current_database()::information_schema.sql_identifier AS routine_catalog,\n    np.nspname::information_schema.sql_identifier AS routine_schema,\n    p.proname::information_schema.sql_identifier AS routine_name,\n    current_database()::information_schema.sql_identifier AS table_catalog,\n    nt.nspname::information_schema.sql_identifier AS table_schema,\n    t.relname::information_schema.sql_identifier AS table_name,\n    a.attname::information_schema.sql_identifier AS column_name\n   FROM pg_namespace np,\n    pg_proc p,\n    pg_depend d,\n    pg_class t,\n    pg_namespace nt,\n    pg_attribute a\n  WHERE np.oid = p.pronamespace AND p.oid = d.objid AND d.classid = 'pg_proc'::regclass::oid AND d.refobjid = t.oid AND d.refclassid = 'pg_class'::regclass::oid AND t.relnamespace = nt.oid AND (t.relkind = ANY (ARRAY['r'::""char"", 'v'::""char"", 'f'::""char"", 'p'::""char""])) AND t.oid = a.attrelid AND d.refobjsubid = a.attnum AND pg_has_role(t.relowner, 'USAGE'::text);"
information_schema	routine_privileges		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	10	0	" SELECT u_grantor.rolname::information_schema.sql_identifier AS grantor,\n    grantee.rolname::information_schema.sql_identifier AS grantee,\n    current_database()::information_schema.sql_identifier AS specific_catalog,\n    n.nspname::information_schema.sql_identifier AS specific_schema,\n    nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,\n    current_database()::information_schema.sql_identifier AS routine_catalog,\n    n.nspname::information_schema.sql_identifier AS routine_schema,\n    p.proname::information_schema.sql_identifier AS routine_name,\n    'EXECUTE'::character varying::information_schema.character_data AS privilege_type,\n        CASE\n            WHEN pg_has_role(grantee.oid, p.proowner, 'USAGE'::text) OR p.grantable THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_grantable\n   FROM ( SELECT pg_proc.oid,\n            pg_proc.proname,\n            pg_proc.proowner,\n            pg_proc.pronamespace,\n            (aclexplode(COALESCE(pg_proc.proacl, acldefault('f'::""char"", pg_proc.proowner)))).grantor AS grantor,\n            (aclexplode(COALESCE(pg_proc.proacl, acldefault('f'::""char"", pg_proc.proowner)))).grantee AS grantee,\n            (aclexplode(COALESCE(pg_proc.proacl, acldefault('f'::""char"", pg_proc.proowner)))).privilege_type AS privilege_type,\n            (aclexplode(COALESCE(pg_proc.proacl, acldefault('f'::""char"", pg_proc.proowner)))).is_grantable AS is_grantable\n           FROM pg_proc) p(oid, proname, proowner, pronamespace, grantor, grantee, prtype, grantable),\n    pg_namespace n,\n    pg_authid u_grantor,\n    ( SELECT pg_authid.oid,\n            pg_authid.rolname\n           FROM pg_authid\n        UNION ALL\n         SELECT 0::oid AS oid,\n            'PUBLIC'::name) grantee(oid, rolname)\n  WHERE p.pronamespace = n.oid AND grantee.oid = p.grantee AND u_grantor.oid = p.grantor AND p.prtype = 'EXECUTE'::text AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR grantee.rolname = 'PUBLIC'::name);"
information_schema	routine_routine_usage		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	6	0	" SELECT DISTINCT current_database()::information_schema.sql_identifier AS specific_catalog,\n    np.nspname::information_schema.sql_identifier AS specific_schema,\n    nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,\n    current_database()::information_schema.sql_identifier AS routine_catalog,\n    np1.nspname::information_schema.sql_identifier AS routine_schema,\n    nameconcatoid(p1.proname, p1.oid)::information_schema.sql_identifier AS routine_name\n   FROM pg_namespace np,\n    pg_proc p,\n    pg_depend d,\n    pg_proc p1,\n    pg_namespace np1\n  WHERE np.oid = p.pronamespace AND p.oid = d.objid AND d.classid = 'pg_proc'::regclass::oid AND d.refobjid = p1.oid AND d.refclassid = 'pg_proc'::regclass::oid AND p1.pronamespace = np1.oid AND (p.prokind = ANY (ARRAY['f'::""char"", 'p'::""char""])) AND (p1.prokind = ANY (ARRAY['f'::""char"", 'p'::""char""])) AND pg_has_role(p1.proowner, 'USAGE'::text);"
information_schema	routine_sequence_usage		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	9	0	" SELECT DISTINCT current_database()::information_schema.sql_identifier AS specific_catalog,\n    np.nspname::information_schema.sql_identifier AS specific_schema,\n    nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,\n    current_database()::information_schema.sql_identifier AS routine_catalog,\n    np.nspname::information_schema.sql_identifier AS routine_schema,\n    p.proname::information_schema.sql_identifier AS routine_name,\n    current_database()::information_schema.sql_identifier AS sequence_catalog,\n    ns.nspname::information_schema.sql_identifier AS sequence_schema,\n    s.relname::information_schema.sql_identifier AS sequence_name\n   FROM pg_namespace np,\n    pg_proc p,\n    pg_depend d,\n    pg_class s,\n    pg_namespace ns\n  WHERE np.oid = p.pronamespace AND p.oid = d.objid AND d.classid = 'pg_proc'::regclass::oid AND d.refobjid = s.oid AND d.refclassid = 'pg_class'::regclass::oid AND s.relnamespace = ns.oid AND s.relkind = 'S'::""char"" AND pg_has_role(s.relowner, 'USAGE'::text);"
information_schema	routine_table_usage		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	9	0	" SELECT DISTINCT current_database()::information_schema.sql_identifier AS specific_catalog,\n    np.nspname::information_schema.sql_identifier AS specific_schema,\n    nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,\n    current_database()::information_schema.sql_identifier AS routine_catalog,\n    np.nspname::information_schema.sql_identifier AS routine_schema,\n    p.proname::information_schema.sql_identifier AS routine_name,\n    current_database()::information_schema.sql_identifier AS table_catalog,\n    nt.nspname::information_schema.sql_identifier AS table_schema,\n    t.relname::information_schema.sql_identifier AS table_name\n   FROM pg_namespace np,\n    pg_proc p,\n    pg_depend d,\n    pg_class t,\n    pg_namespace nt\n  WHERE np.oid = p.pronamespace AND p.oid = d.objid AND d.classid = 'pg_proc'::regclass::oid AND d.refobjid = t.oid AND d.refclassid = 'pg_class'::regclass::oid AND t.relnamespace = nt.oid AND (t.relkind = ANY (ARRAY['r'::""char"", 'v'::""char"", 'f'::""char"", 'p'::""char""])) AND pg_has_role(t.relowner, 'USAGE'::text);"
information_schema	routines		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	82	0	" SELECT current_database()::information_schema.sql_identifier AS specific_catalog,\n    n.nspname::information_schema.sql_identifier AS specific_schema,\n    nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,\n    current_database()::information_schema.sql_identifier AS routine_catalog,\n    n.nspname::information_schema.sql_identifier AS routine_schema,\n    p.proname::information_schema.sql_identifier AS routine_name,\n        CASE p.prokind\n            WHEN 'f'::""char"" THEN 'FUNCTION'::text\n            WHEN 'p'::""char"" THEN 'PROCEDURE'::text\n            ELSE NULL::text\n        END::information_schema.character_data AS routine_type,\n    NULL::name::information_schema.sql_identifier AS module_catalog,\n    NULL::name::information_schema.sql_identifier AS module_schema,\n    NULL::name::information_schema.sql_identifier AS module_name,\n    NULL::name::information_schema.sql_identifier AS udt_catalog,\n    NULL::name::information_schema.sql_identifier AS udt_schema,\n    NULL::name::information_schema.sql_identifier AS udt_name,\n        CASE\n            WHEN p.prokind = 'p'::""char"" THEN NULL::text\n            WHEN t.typelem <> 0::oid AND t.typlen = '-1'::integer THEN 'ARRAY'::text\n            WHEN nt.nspname = 'pg_catalog'::name THEN format_type(t.oid, NULL::integer)\n            ELSE 'USER-DEFINED'::text\n        END::information_schema.character_data AS data_type,\n    NULL::integer::information_schema.cardinal_number AS character_maximum_length,\n    NULL::integer::information_schema.cardinal_number AS character_octet_length,\n    NULL::name::information_schema.sql_identifier AS character_set_catalog,\n    NULL::name::information_schema.sql_identifier AS character_set_schema,\n    NULL::name::information_schema.sql_identifier AS character_set_name,\n    NULL::name::information_schema.sql_identifier AS collation_catalog,\n    NULL::name::information_schema.sql_identifier AS collation_schema,\n    NULL::name::information_schema.sql_identifier AS collation_name,\n    NULL::integer::information_schema.cardinal_number AS numeric_precision,\n    NULL::integer::information_schema.cardinal_number AS numeric_precision_radix,\n    NULL::integer::information_schema.cardinal_number AS numeric_scale,\n    NULL::integer::information_schema.cardinal_number AS datetime_precision,\n    NULL::character varying::information_schema.character_data AS interval_type,\n    NULL::integer::information_schema.cardinal_number AS interval_precision,\n        CASE\n            WHEN nt.nspname IS NOT NULL THEN current_database()\n            ELSE NULL::name\n        END::information_schema.sql_identifier AS type_udt_catalog,\n    nt.nspname::information_schema.sql_identifier AS type_udt_schema,\n    t.typname::information_schema.sql_identifier AS type_udt_name,\n    NULL::name::information_schema.sql_identifier AS scope_catalog,\n    NULL::name::information_schema.sql_identifier AS scope_schema,\n    NULL::name::information_schema.sql_identifier AS scope_name,\n    NULL::integer::information_schema.cardinal_number AS maximum_cardinality,\n        CASE\n            WHEN p.prokind <> 'p'::""char"" THEN 0\n            ELSE NULL::integer\n        END::information_schema.sql_identifier AS dtd_identifier,\n        CASE\n            WHEN l.lanname = 'sql'::name THEN 'SQL'::text\n            ELSE 'EXTERNAL'::text\n        END::information_schema.character_data AS routine_body,\n        CASE\n            WHEN pg_has_role(p.proowner, 'USAGE'::text) THEN p.prosrc\n            ELSE NULL::text\n        END::information_schema.character_data AS routine_definition,\n        CASE\n            WHEN l.lanname = 'c'::name THEN p.prosrc\n            ELSE NULL::text\n        END::information_schema.character_data AS external_name,\n    upper(l.lanname::text)::information_schema.character_data AS external_language,\n    'GENERAL'::character varying::information_schema.character_data AS parameter_style,\n        CASE\n            WHEN p.provolatile = 'i'::""char"" THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_deterministic,\n    'MODIFIES'::character varying::information_schema.character_data AS sql_data_access,\n        CASE\n            WHEN p.prokind <> 'p'::""char"" THEN\n            CASE\n                WHEN p.proisstrict THEN 'YES'::text\n                ELSE 'NO'::text\n            END\n            ELSE NULL::text\n        END::information_schema.yes_or_no AS is_null_call,\n    NULL::character varying::information_schema.character_data AS sql_path,\n    'YES'::character varying::information_schema.yes_or_no AS schema_level_routine,\n    0::information_schema.cardinal_number AS max_dynamic_result_sets,\n    NULL::character varying::information_schema.yes_or_no AS is_user_defined_cast,\n    NULL::character varying::information_schema.yes_or_no AS is_implicitly_invocable,\n        CASE\n            WHEN p.prosecdef THEN 'DEFINER'::text\n            ELSE 'INVOKER'::text\n        END::information_schema.character_data AS security_type,\n    NULL::name::information_schema.sql_identifier AS to_sql_specific_catalog,\n    NULL::name::information_schema.sql_identifier AS to_sql_specific_schema,\n    NULL::name::information_schema.sql_identifier AS to_sql_specific_name,\n    'NO'::character varying::information_schema.yes_or_no AS as_locator,\n    NULL::timestamp with time zone::information_schema.time_stamp AS created,\n    NULL::timestamp with time zone::information_schema.time_stamp AS last_altered,\n    NULL::character varying::information_schema.yes_or_no AS new_savepoint_level,\n    'NO'::character varying::information_schema.yes_or_no AS is_udt_dependent,\n    NULL::character varying::information_schema.character_data AS result_cast_from_data_type,\n    NULL::character varying::information_schema.yes_or_no AS result_cast_as_locator,\n    NULL::integer::information_schema.cardinal_number AS result_cast_char_max_length,\n    NULL::integer::information_schema.cardinal_number AS result_cast_char_octet_length,\n    NULL::name::information_schema.sql_identifier AS result_cast_char_set_catalog,\n    NULL::name::information_schema.sql_identifier AS result_cast_char_set_schema,\n    NULL::name::information_schema.sql_identifier AS result_cast_char_set_name,\n    NULL::name::information_schema.sql_identifier AS result_cast_collation_catalog,\n    NULL::name::information_schema.sql_identifier AS result_cast_collation_schema,\n    NULL::name::information_schema.sql_identifier AS result_cast_collation_name,\n    NULL::integer::information_schema.cardinal_number AS result_cast_numeric_precision,\n    NULL::integer::information_schema.cardinal_number AS result_cast_numeric_precision_radix,\n    NULL::integer::information_schema.cardinal_number AS result_cast_numeric_scale,\n    NULL::integer::information_schema.cardinal_number AS result_cast_datetime_precision,\n    NULL::character varying::information_schema.character_data AS result_cast_interval_type,\n    NULL::integer::information_schema.cardinal_number AS result_cast_interval_precision,\n    NULL::name::information_schema.sql_identifier AS result_cast_type_udt_catalog,\n    NULL::name::information_schema.sql_identifier AS result_cast_type_udt_schema,\n    NULL::name::information_schema.sql_identifier AS result_cast_type_udt_name,\n    NULL::name::information_schema.sql_identifier AS result_cast_scope_catalog,\n    NULL::name::information_schema.sql_identifier AS result_cast_scope_schema,\n    NULL::name::information_schema.sql_identifier AS result_cast_scope_name,\n    NULL::integer::information_schema.cardinal_number AS result_cast_maximum_cardinality,\n    NULL::name::information_schema.sql_identifier AS result_cast_dtd_identifier\n   FROM pg_namespace n\n     JOIN pg_proc p ON n.oid = p.pronamespace\n     JOIN pg_language l ON p.prolang = l.oid\n     LEFT JOIN (pg_type t\n     JOIN pg_namespace nt ON t.typnamespace = nt.oid) ON p.prorettype = t.oid AND p.prokind <> 'p'::""char""\n  WHERE pg_has_role(p.proowner, 'USAGE'::text) OR has_function_privilege(p.oid, 'EXECUTE'::text);"
information_schema	schemata		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	7	0	" SELECT current_database()::information_schema.sql_identifier AS catalog_name,\n    n.nspname::information_schema.sql_identifier AS schema_name,\n    u.rolname::information_schema.sql_identifier AS schema_owner,\n    NULL::name::information_schema.sql_identifier AS default_character_set_catalog,\n    NULL::name::information_schema.sql_identifier AS default_character_set_schema,\n    NULL::name::information_schema.sql_identifier AS default_character_set_name,\n    NULL::character varying::information_schema.character_data AS sql_path\n   FROM pg_namespace n,\n    pg_authid u\n  WHERE n.nspowner = u.oid AND (pg_has_role(n.nspowner, 'USAGE'::text) OR has_schema_privilege(n.oid, 'CREATE, USAGE'::text));"
information_schema	sequences		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	12	0	" SELECT current_database()::information_schema.sql_identifier AS sequence_catalog,\n    nc.nspname::information_schema.sql_identifier AS sequence_schema,\n    c.relname::information_schema.sql_identifier AS sequence_name,\n    format_type(s.seqtypid, NULL::integer)::information_schema.character_data AS data_type,\n    information_schema._pg_numeric_precision(s.seqtypid, '-1'::integer)::information_schema.cardinal_number AS numeric_precision,\n    2::information_schema.cardinal_number AS numeric_precision_radix,\n    0::information_schema.cardinal_number AS numeric_scale,\n    s.seqstart::information_schema.character_data AS start_value,\n    s.seqmin::information_schema.character_data AS minimum_value,\n    s.seqmax::information_schema.character_data AS maximum_value,\n    s.seqincrement::information_schema.character_data AS increment,\n        CASE\n            WHEN s.seqcycle THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS cycle_option\n   FROM pg_namespace nc,\n    pg_class c,\n    pg_sequence s\n  WHERE c.relnamespace = nc.oid AND c.relkind = 'S'::""char"" AND NOT (EXISTS ( SELECT 1\n           FROM pg_depend\n          WHERE pg_depend.classid = 'pg_class'::regclass::oid AND pg_depend.objid = c.oid AND pg_depend.deptype = 'i'::""char"")) AND NOT pg_is_other_temp_schema(nc.oid) AND c.oid = s.seqrelid AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_sequence_privilege(c.oid, 'SELECT, UPDATE, USAGE'::text));"
information_schema	table_constraints		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	10	0	" SELECT current_database()::information_schema.sql_identifier AS constraint_catalog,\n    nc.nspname::information_schema.sql_identifier AS constraint_schema,\n    c.conname::information_schema.sql_identifier AS constraint_name,\n    current_database()::information_schema.sql_identifier AS table_catalog,\n    nr.nspname::information_schema.sql_identifier AS table_schema,\n    r.relname::information_schema.sql_identifier AS table_name,\n        CASE c.contype\n            WHEN 'c'::""char"" THEN 'CHECK'::text\n            WHEN 'f'::""char"" THEN 'FOREIGN KEY'::text\n            WHEN 'p'::""char"" THEN 'PRIMARY KEY'::text\n            WHEN 'u'::""char"" THEN 'UNIQUE'::text\n            ELSE NULL::text\n        END::information_schema.character_data AS constraint_type,\n        CASE\n            WHEN c.condeferrable THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_deferrable,\n        CASE\n            WHEN c.condeferred THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS initially_deferred,\n    'YES'::character varying::information_schema.yes_or_no AS enforced\n   FROM pg_namespace nc,\n    pg_namespace nr,\n    pg_constraint c,\n    pg_class r\n  WHERE nc.oid = c.connamespace AND nr.oid = r.relnamespace AND c.conrelid = r.oid AND (c.contype <> ALL (ARRAY['t'::""char"", 'x'::""char""])) AND (r.relkind = ANY (ARRAY['r'::""char"", 'p'::""char""])) AND NOT pg_is_other_temp_schema(nr.oid) AND (pg_has_role(r.relowner, 'USAGE'::text) OR has_table_privilege(r.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(r.oid, 'INSERT, UPDATE, REFERENCES'::text))\nUNION ALL\n SELECT current_database()::information_schema.sql_identifier AS constraint_catalog,\n    nr.nspname::information_schema.sql_identifier AS constraint_schema,\n    (((((nr.oid::text || '_'::text) || r.oid::text) || '_'::text) || a.attnum::text) || '_not_null'::text)::information_schema.sql_identifier AS constraint_name,\n    current_database()::information_schema.sql_identifier AS table_catalog,\n    nr.nspname::information_schema.sql_identifier AS table_schema,\n    r.relname::information_schema.sql_identifier AS table_name,\n    'CHECK'::character varying::information_schema.character_data AS constraint_type,\n    'NO'::character varying::information_schema.yes_or_no AS is_deferrable,\n    'NO'::character varying::information_schema.yes_or_no AS initially_deferred,\n    'YES'::character varying::information_schema.yes_or_no AS enforced\n   FROM pg_namespace nr,\n    pg_class r,\n    pg_attribute a\n  WHERE nr.oid = r.relnamespace AND r.oid = a.attrelid AND a.attnotnull AND a.attnum > 0 AND NOT a.attisdropped AND (r.relkind = ANY (ARRAY['r'::""char"", 'p'::""char""])) AND NOT pg_is_other_temp_schema(nr.oid) AND (pg_has_role(r.relowner, 'USAGE'::text) OR has_table_privilege(r.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(r.oid, 'INSERT, UPDATE, REFERENCES'::text));"
information_schema	table_privileges		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	8	0	" SELECT u_grantor.rolname::information_schema.sql_identifier AS grantor,\n    grantee.rolname::information_schema.sql_identifier AS grantee,\n    current_database()::information_schema.sql_identifier AS table_catalog,\n    nc.nspname::information_schema.sql_identifier AS table_schema,\n    c.relname::information_schema.sql_identifier AS table_name,\n    c.prtype::information_schema.character_data AS privilege_type,\n        CASE\n            WHEN pg_has_role(grantee.oid, c.relowner, 'USAGE'::text) OR c.grantable THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_grantable,\n        CASE\n            WHEN c.prtype = 'SELECT'::text THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS with_hierarchy\n   FROM ( SELECT pg_class.oid,\n            pg_class.relname,\n            pg_class.relnamespace,\n            pg_class.relkind,\n            pg_class.relowner,\n            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::""char"", pg_class.relowner)))).grantor AS grantor,\n            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::""char"", pg_class.relowner)))).grantee AS grantee,\n            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::""char"", pg_class.relowner)))).privilege_type AS privilege_type,\n            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::""char"", pg_class.relowner)))).is_grantable AS is_grantable\n           FROM pg_class) c(oid, relname, relnamespace, relkind, relowner, grantor, grantee, prtype, grantable),\n    pg_namespace nc,\n    pg_authid u_grantor,\n    ( SELECT pg_authid.oid,\n            pg_authid.rolname\n           FROM pg_authid\n        UNION ALL\n         SELECT 0::oid AS oid,\n            'PUBLIC'::name) grantee(oid, rolname)\n  WHERE c.relnamespace = nc.oid AND (c.relkind = ANY (ARRAY['r'::""char"", 'v'::""char"", 'f'::""char"", 'p'::""char""])) AND c.grantee = grantee.oid AND c.grantor = u_grantor.oid AND (c.prtype = ANY (ARRAY['INSERT'::text, 'SELECT'::text, 'UPDATE'::text, 'DELETE'::text, 'TRUNCATE'::text, 'REFERENCES'::text, 'TRIGGER'::text])) AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR grantee.rolname = 'PUBLIC'::name);"
information_schema	tables		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	12	0	" SELECT current_database()::information_schema.sql_identifier AS table_catalog,\n    nc.nspname::information_schema.sql_identifier AS table_schema,\n    c.relname::information_schema.sql_identifier AS table_name,\n        CASE\n            WHEN nc.oid = pg_my_temp_schema() THEN 'LOCAL TEMPORARY'::text\n            WHEN c.relkind = ANY (ARRAY['r'::""char"", 'p'::""char""]) THEN 'BASE TABLE'::text\n            WHEN c.relkind = 'v'::""char"" THEN 'VIEW'::text\n            WHEN c.relkind = 'f'::""char"" THEN 'FOREIGN'::text\n            ELSE NULL::text\n        END::information_schema.character_data AS table_type,\n    NULL::name::information_schema.sql_identifier AS self_referencing_column_name,\n    NULL::character varying::information_schema.character_data AS reference_generation,\n        CASE\n            WHEN t.typname IS NOT NULL THEN current_database()\n            ELSE NULL::name\n        END::information_schema.sql_identifier AS user_defined_type_catalog,\n    nt.nspname::information_schema.sql_identifier AS user_defined_type_schema,\n    t.typname::information_schema.sql_identifier AS user_defined_type_name,\n        CASE\n            WHEN (c.relkind = ANY (ARRAY['r'::""char"", 'p'::""char""])) OR (c.relkind = ANY (ARRAY['v'::""char"", 'f'::""char""])) AND (pg_relation_is_updatable(c.oid::regclass, false) & 8) = 8 THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_insertable_into,\n        CASE\n            WHEN t.typname IS NOT NULL THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_typed,\n    NULL::character varying::information_schema.character_data AS commit_action\n   FROM pg_namespace nc\n     JOIN pg_class c ON nc.oid = c.relnamespace\n     LEFT JOIN (pg_type t\n     JOIN pg_namespace nt ON t.typnamespace = nt.oid) ON c.reloftype = t.oid\n  WHERE (c.relkind = ANY (ARRAY['r'::""char"", 'v'::""char"", 'f'::""char"", 'p'::""char""])) AND NOT pg_is_other_temp_schema(nc.oid) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text));"
information_schema	transforms		postgres			3328	v	-1		0	0	8	0	" SELECT current_database()::information_schema.sql_identifier AS udt_catalog,\n    nt.nspname::information_schema.sql_identifier AS udt_schema,\n    t.typname::information_schema.sql_identifier AS udt_name,\n    current_database()::information_schema.sql_identifier AS specific_catalog,\n    np.nspname::information_schema.sql_identifier AS specific_schema,\n    nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,\n    l.lanname::information_schema.sql_identifier AS group_name,\n    'FROM SQL'::character varying::information_schema.character_data AS transform_type\n   FROM pg_type t\n     JOIN pg_transform x ON t.oid = x.trftype\n     JOIN pg_language l ON x.trflang = l.oid\n     JOIN pg_proc p ON x.trffromsql::oid = p.oid\n     JOIN pg_namespace nt ON t.typnamespace = nt.oid\n     JOIN pg_namespace np ON p.pronamespace = np.oid\nUNION\n SELECT current_database()::information_schema.sql_identifier AS udt_catalog,\n    nt.nspname::information_schema.sql_identifier AS udt_schema,\n    t.typname::information_schema.sql_identifier AS udt_name,\n    current_database()::information_schema.sql_identifier AS specific_catalog,\n    np.nspname::information_schema.sql_identifier AS specific_schema,\n    nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,\n    l.lanname::information_schema.sql_identifier AS group_name,\n    'TO SQL'::character varying::information_schema.character_data AS transform_type\n   FROM pg_type t\n     JOIN pg_transform x ON t.oid = x.trftype\n     JOIN pg_language l ON x.trflang = l.oid\n     JOIN pg_proc p ON x.trftosql::oid = p.oid\n     JOIN pg_namespace nt ON t.typnamespace = nt.oid\n     JOIN pg_namespace np ON p.pronamespace = np.oid\n  ORDER BY 1, 2, 3, 7, 8;"
information_schema	triggered_update_columns		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	7	0	" SELECT current_database()::information_schema.sql_identifier AS trigger_catalog,\n    n.nspname::information_schema.sql_identifier AS trigger_schema,\n    t.tgname::information_schema.sql_identifier AS trigger_name,\n    current_database()::information_schema.sql_identifier AS event_object_catalog,\n    n.nspname::information_schema.sql_identifier AS event_object_schema,\n    c.relname::information_schema.sql_identifier AS event_object_table,\n    a.attname::information_schema.sql_identifier AS event_object_column\n   FROM pg_namespace n,\n    pg_class c,\n    pg_trigger t,\n    ( SELECT ta0.tgoid,\n            (ta0.tgat).x AS tgattnum,\n            (ta0.tgat).n AS tgattpos\n           FROM ( SELECT pg_trigger.oid AS tgoid,\n                    information_schema._pg_expandarray(pg_trigger.tgattr) AS tgat\n                   FROM pg_trigger) ta0) ta,\n    pg_attribute a\n  WHERE n.oid = c.relnamespace AND c.oid = t.tgrelid AND t.oid = ta.tgoid AND a.attrelid = t.tgrelid AND a.attnum = ta.tgattnum AND NOT t.tgisinternal AND NOT pg_is_other_temp_schema(n.oid) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_column_privilege(c.oid, a.attnum, 'INSERT, UPDATE, REFERENCES'::text));"
information_schema	triggers		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	17	0	" SELECT current_database()::information_schema.sql_identifier AS trigger_catalog,\n    n.nspname::information_schema.sql_identifier AS trigger_schema,\n    t.tgname::information_schema.sql_identifier AS trigger_name,\n    em.text::information_schema.character_data AS event_manipulation,\n    current_database()::information_schema.sql_identifier AS event_object_catalog,\n    n.nspname::information_schema.sql_identifier AS event_object_schema,\n    c.relname::information_schema.sql_identifier AS event_object_table,\n    rank() OVER (PARTITION BY (n.nspname::information_schema.sql_identifier), (c.relname::information_schema.sql_identifier), em.num, (t.tgtype::integer & 1), (t.tgtype::integer & 66) ORDER BY t.tgname)::information_schema.cardinal_number AS action_order,\n        CASE\n            WHEN pg_has_role(c.relowner, 'USAGE'::text) THEN (regexp_match(pg_get_triggerdef(t.oid), '.{35,} WHEN \((.+)\) EXECUTE FUNCTION'::text))[1]\n            ELSE NULL::text\n        END::information_schema.character_data AS action_condition,\n    SUBSTRING(pg_get_triggerdef(t.oid) FROM POSITION(('EXECUTE FUNCTION'::text) IN (SUBSTRING(pg_get_triggerdef(t.oid) FROM 48))) + 47)::information_schema.character_data AS action_statement,\n        CASE t.tgtype::integer & 1\n            WHEN 1 THEN 'ROW'::text\n            ELSE 'STATEMENT'::text\n        END::information_schema.character_data AS action_orientation,\n        CASE t.tgtype::integer & 66\n            WHEN 2 THEN 'BEFORE'::text\n            WHEN 64 THEN 'INSTEAD OF'::text\n            ELSE 'AFTER'::text\n        END::information_schema.character_data AS action_timing,\n    t.tgoldtable::information_schema.sql_identifier AS action_reference_old_table,\n    t.tgnewtable::information_schema.sql_identifier AS action_reference_new_table,\n    NULL::name::information_schema.sql_identifier AS action_reference_old_row,\n    NULL::name::information_schema.sql_identifier AS action_reference_new_row,\n    NULL::timestamp with time zone::information_schema.time_stamp AS created\n   FROM pg_namespace n,\n    pg_class c,\n    pg_trigger t,\n    ( VALUES (4,'INSERT'::text), (8,'DELETE'::text), (16,'UPDATE'::text)) em(num, text)\n  WHERE n.oid = c.relnamespace AND c.oid = t.tgrelid AND (t.tgtype::integer & em.num) <> 0 AND NOT t.tgisinternal AND NOT pg_is_other_temp_schema(n.oid) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES'::text));"
information_schema	udt_privileges		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	7	0	" SELECT u_grantor.rolname::information_schema.sql_identifier AS grantor,\n    grantee.rolname::information_schema.sql_identifier AS grantee,\n    current_database()::information_schema.sql_identifier AS udt_catalog,\n    n.nspname::information_schema.sql_identifier AS udt_schema,\n    t.typname::information_schema.sql_identifier AS udt_name,\n    'TYPE USAGE'::character varying::information_schema.character_data AS privilege_type,\n        CASE\n            WHEN pg_has_role(grantee.oid, t.typowner, 'USAGE'::text) OR t.grantable THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_grantable\n   FROM ( SELECT pg_type.oid,\n            pg_type.typname,\n            pg_type.typnamespace,\n            pg_type.typtype,\n            pg_type.typowner,\n            (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::""char"", pg_type.typowner)))).grantor AS grantor,\n            (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::""char"", pg_type.typowner)))).grantee AS grantee,\n            (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::""char"", pg_type.typowner)))).privilege_type AS privilege_type,\n            (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::""char"", pg_type.typowner)))).is_grantable AS is_grantable\n           FROM pg_type) t(oid, typname, typnamespace, typtype, typowner, grantor, grantee, prtype, grantable),\n    pg_namespace n,\n    pg_authid u_grantor,\n    ( SELECT pg_authid.oid,\n            pg_authid.rolname\n           FROM pg_authid\n        UNION ALL\n         SELECT 0::oid AS oid,\n            'PUBLIC'::name) grantee(oid, rolname)\n  WHERE t.typnamespace = n.oid AND t.typtype = 'c'::""char"" AND t.grantee = grantee.oid AND t.grantor = u_grantor.oid AND t.prtype = 'USAGE'::text AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR grantee.rolname = 'PUBLIC'::name);"
information_schema	usage_privileges		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	8	0	" SELECT u.rolname::information_schema.sql_identifier AS grantor,\n    'PUBLIC'::name::information_schema.sql_identifier AS grantee,\n    current_database()::information_schema.sql_identifier AS object_catalog,\n    n.nspname::information_schema.sql_identifier AS object_schema,\n    c.collname::information_schema.sql_identifier AS object_name,\n    'COLLATION'::character varying::information_schema.character_data AS object_type,\n    'USAGE'::character varying::information_schema.character_data AS privilege_type,\n    'NO'::character varying::information_schema.yes_or_no AS is_grantable\n   FROM pg_authid u,\n    pg_namespace n,\n    pg_collation c\n  WHERE u.oid = c.collowner AND c.collnamespace = n.oid AND (c.collencoding = ANY (ARRAY['-1'::integer, ( SELECT pg_database.encoding\n           FROM pg_database\n          WHERE pg_database.datname = current_database())]))\nUNION ALL\n SELECT u_grantor.rolname::information_schema.sql_identifier AS grantor,\n    grantee.rolname::information_schema.sql_identifier AS grantee,\n    current_database()::information_schema.sql_identifier AS object_catalog,\n    n.nspname::information_schema.sql_identifier AS object_schema,\n    t.typname::information_schema.sql_identifier AS object_name,\n    'DOMAIN'::character varying::information_schema.character_data AS object_type,\n    'USAGE'::character varying::information_schema.character_data AS privilege_type,\n        CASE\n            WHEN pg_has_role(grantee.oid, t.typowner, 'USAGE'::text) OR t.grantable THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_grantable\n   FROM ( SELECT pg_type.oid,\n            pg_type.typname,\n            pg_type.typnamespace,\n            pg_type.typtype,\n            pg_type.typowner,\n            (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::""char"", pg_type.typowner)))).grantor AS grantor,\n            (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::""char"", pg_type.typowner)))).grantee AS grantee,\n            (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::""char"", pg_type.typowner)))).privilege_type AS privilege_type,\n            (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::""char"", pg_type.typowner)))).is_grantable AS is_grantable\n           FROM pg_type) t(oid, typname, typnamespace, typtype, typowner, grantor, grantee, prtype, grantable),\n    pg_namespace n,\n    pg_authid u_grantor,\n    ( SELECT pg_authid.oid,\n            pg_authid.rolname\n           FROM pg_authid\n        UNION ALL\n         SELECT 0::oid AS oid,\n            'PUBLIC'::name) grantee(oid, rolname)\n  WHERE t.typnamespace = n.oid AND t.typtype = 'd'::""char"" AND t.grantee = grantee.oid AND t.grantor = u_grantor.oid AND t.prtype = 'USAGE'::text AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR grantee.rolname = 'PUBLIC'::name)\nUNION ALL\n SELECT u_grantor.rolname::information_schema.sql_identifier AS grantor,\n    grantee.rolname::information_schema.sql_identifier AS grantee,\n    current_database()::information_schema.sql_identifier AS object_catalog,\n    ''::name::information_schema.sql_identifier AS object_schema,\n    fdw.fdwname::information_schema.sql_identifier AS object_name,\n    'FOREIGN DATA WRAPPER'::character varying::information_schema.character_data AS object_type,\n    'USAGE'::character varying::information_schema.character_data AS privilege_type,\n        CASE\n            WHEN pg_has_role(grantee.oid, fdw.fdwowner, 'USAGE'::text) OR fdw.grantable THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_grantable\n   FROM ( SELECT pg_foreign_data_wrapper.fdwname,\n            pg_foreign_data_wrapper.fdwowner,\n            (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl, acldefault('F'::""char"", pg_foreign_data_wrapper.fdwowner)))).grantor AS grantor,\n            (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl, acldefault('F'::""char"", pg_foreign_data_wrapper.fdwowner)))).grantee AS grantee,\n            (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl, acldefault('F'::""char"", pg_foreign_data_wrapper.fdwowner)))).privilege_type AS privilege_type,\n            (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl, acldefault('F'::""char"", pg_foreign_data_wrapper.fdwowner)))).is_grantable AS is_grantable\n           FROM pg_foreign_data_wrapper) fdw(fdwname, fdwowner, grantor, grantee, prtype, grantable),\n    pg_authid u_grantor,\n    ( SELECT pg_authid.oid,\n            pg_authid.rolname\n           FROM pg_authid\n        UNION ALL\n         SELECT 0::oid AS oid,\n            'PUBLIC'::name) grantee(oid, rolname)\n  WHERE u_grantor.oid = fdw.grantor AND grantee.oid = fdw.grantee AND fdw.prtype = 'USAGE'::text AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR grantee.rolname = 'PUBLIC'::name)\nUNION ALL\n SELECT u_grantor.rolname::information_schema.sql_identifier AS grantor,\n    grantee.rolname::information_schema.sql_identifier AS grantee,\n    current_database()::information_schema.sql_identifier AS object_catalog,\n    ''::name::information_schema.sql_identifier AS object_schema,\n    srv.srvname::information_schema.sql_identifier AS object_name,\n    'FOREIGN SERVER'::character varying::information_schema.character_data AS object_type,\n    'USAGE'::character varying::information_schema.character_data AS privilege_type,\n        CASE\n            WHEN pg_has_role(grantee.oid, srv.srvowner, 'USAGE'::text) OR srv.grantable THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_grantable\n   FROM ( SELECT pg_foreign_server.srvname,\n            pg_foreign_server.srvowner,\n            (aclexplode(COALESCE(pg_foreign_server.srvacl, acldefault('S'::""char"", pg_foreign_server.srvowner)))).grantor AS grantor,\n            (aclexplode(COALESCE(pg_foreign_server.srvacl, acldefault('S'::""char"", pg_foreign_server.srvowner)))).grantee AS grantee,\n            (aclexplode(COALESCE(pg_foreign_server.srvacl, acldefault('S'::""char"", pg_foreign_server.srvowner)))).privilege_type AS privilege_type,\n            (aclexplode(COALESCE(pg_foreign_server.srvacl, acldefault('S'::""char"", pg_foreign_server.srvowner)))).is_grantable AS is_grantable\n           FROM pg_foreign_server) srv(srvname, srvowner, grantor, grantee, prtype, grantable),\n    pg_authid u_grantor,\n    ( SELECT pg_authid.oid,\n            pg_authid.rolname\n           FROM pg_authid\n        UNION ALL\n         SELECT 0::oid AS oid,\n            'PUBLIC'::name) grantee(oid, rolname)\n  WHERE u_grantor.oid = srv.grantor AND grantee.oid = srv.grantee AND srv.prtype = 'USAGE'::text AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR grantee.rolname = 'PUBLIC'::name)\nUNION ALL\n SELECT u_grantor.rolname::information_schema.sql_identifier AS grantor,\n    grantee.rolname::information_schema.sql_identifier AS grantee,\n    current_database()::information_schema.sql_identifier AS object_catalog,\n    n.nspname::information_schema.sql_identifier AS object_schema,\n    c.relname::information_schema.sql_identifier AS object_name,\n    'SEQUENCE'::character varying::information_schema.character_data AS object_type,\n    'USAGE'::character varying::information_schema.character_data AS privilege_type,\n        CASE\n            WHEN pg_has_role(grantee.oid, c.relowner, 'USAGE'::text) OR c.grantable THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_grantable\n   FROM ( SELECT pg_class.oid,\n            pg_class.relname,\n            pg_class.relnamespace,\n            pg_class.relkind,\n            pg_class.relowner,\n            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::""char"", pg_class.relowner)))).grantor AS grantor,\n            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::""char"", pg_class.relowner)))).grantee AS grantee,\n            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::""char"", pg_class.relowner)))).privilege_type AS privilege_type,\n            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::""char"", pg_class.relowner)))).is_grantable AS is_grantable\n           FROM pg_class) c(oid, relname, relnamespace, relkind, relowner, grantor, grantee, prtype, grantable),\n    pg_namespace n,\n    pg_authid u_grantor,\n    ( SELECT pg_authid.oid,\n            pg_authid.rolname\n           FROM pg_authid\n        UNION ALL\n         SELECT 0::oid AS oid,\n            'PUBLIC'::name) grantee(oid, rolname)\n  WHERE c.relnamespace = n.oid AND c.relkind = 'S'::""char"" AND c.grantee = grantee.oid AND c.grantor = u_grantor.oid AND c.prtype = 'USAGE'::text AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR grantee.rolname = 'PUBLIC'::name);"
information_schema	user_defined_types		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	29	0	" SELECT current_database()::information_schema.sql_identifier AS user_defined_type_catalog,\n    n.nspname::information_schema.sql_identifier AS user_defined_type_schema,\n    c.relname::information_schema.sql_identifier AS user_defined_type_name,\n    'STRUCTURED'::character varying::information_schema.character_data AS user_defined_type_category,\n    'YES'::character varying::information_schema.yes_or_no AS is_instantiable,\n    NULL::character varying::information_schema.yes_or_no AS is_final,\n    NULL::character varying::information_schema.character_data AS ordering_form,\n    NULL::character varying::information_schema.character_data AS ordering_category,\n    NULL::name::information_schema.sql_identifier AS ordering_routine_catalog,\n    NULL::name::information_schema.sql_identifier AS ordering_routine_schema,\n    NULL::name::information_schema.sql_identifier AS ordering_routine_name,\n    NULL::character varying::information_schema.character_data AS reference_type,\n    NULL::character varying::information_schema.character_data AS data_type,\n    NULL::integer::information_schema.cardinal_number AS character_maximum_length,\n    NULL::integer::information_schema.cardinal_number AS character_octet_length,\n    NULL::name::information_schema.sql_identifier AS character_set_catalog,\n    NULL::name::information_schema.sql_identifier AS character_set_schema,\n    NULL::name::information_schema.sql_identifier AS character_set_name,\n    NULL::name::information_schema.sql_identifier AS collation_catalog,\n    NULL::name::information_schema.sql_identifier AS collation_schema,\n    NULL::name::information_schema.sql_identifier AS collation_name,\n    NULL::integer::information_schema.cardinal_number AS numeric_precision,\n    NULL::integer::information_schema.cardinal_number AS numeric_precision_radix,\n    NULL::integer::information_schema.cardinal_number AS numeric_scale,\n    NULL::integer::information_schema.cardinal_number AS datetime_precision,\n    NULL::character varying::information_schema.character_data AS interval_type,\n    NULL::integer::information_schema.cardinal_number AS interval_precision,\n    NULL::name::information_schema.sql_identifier AS source_dtd_identifier,\n    NULL::name::information_schema.sql_identifier AS ref_dtd_identifier\n   FROM pg_namespace n,\n    pg_class c,\n    pg_type t\n  WHERE n.oid = c.relnamespace AND t.typrelid = c.oid AND c.relkind = 'c'::""char"" AND (pg_has_role(t.typowner, 'USAGE'::text) OR has_type_privilege(t.oid, 'USAGE'::text));"
information_schema	user_mapping_options		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	5	0	" SELECT um.authorization_identifier,\n    um.foreign_server_catalog,\n    um.foreign_server_name,\n    opts.option_name::information_schema.sql_identifier AS option_name,\n        CASE\n            WHEN um.umuser <> 0::oid AND um.authorization_identifier::name = CURRENT_USER OR um.umuser = 0::oid AND pg_has_role(um.srvowner::name, 'USAGE'::text) OR ( SELECT pg_authid.rolsuper\n               FROM pg_authid\n              WHERE pg_authid.rolname = CURRENT_USER) THEN opts.option_value\n            ELSE NULL::text\n        END::information_schema.character_data AS option_value\n   FROM information_schema._pg_user_mappings um,\n    LATERAL pg_options_to_table(um.umoptions) opts(option_name, option_value);"
information_schema	user_mappings		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	3	0	" SELECT _pg_user_mappings.authorization_identifier,\n    _pg_user_mappings.foreign_server_catalog,\n    _pg_user_mappings.foreign_server_name\n   FROM information_schema._pg_user_mappings;"
information_schema	view_column_usage		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	7	0	" SELECT DISTINCT current_database()::information_schema.sql_identifier AS view_catalog,\n    nv.nspname::information_schema.sql_identifier AS view_schema,\n    v.relname::information_schema.sql_identifier AS view_name,\n    current_database()::information_schema.sql_identifier AS table_catalog,\n    nt.nspname::information_schema.sql_identifier AS table_schema,\n    t.relname::information_schema.sql_identifier AS table_name,\n    a.attname::information_schema.sql_identifier AS column_name\n   FROM pg_namespace nv,\n    pg_class v,\n    pg_depend dv,\n    pg_depend dt,\n    pg_class t,\n    pg_namespace nt,\n    pg_attribute a\n  WHERE nv.oid = v.relnamespace AND v.relkind = 'v'::""char"" AND v.oid = dv.refobjid AND dv.refclassid = 'pg_class'::regclass::oid AND dv.classid = 'pg_rewrite'::regclass::oid AND dv.deptype = 'i'::""char"" AND dv.objid = dt.objid AND dv.refobjid <> dt.refobjid AND dt.classid = 'pg_rewrite'::regclass::oid AND dt.refclassid = 'pg_class'::regclass::oid AND dt.refobjid = t.oid AND t.relnamespace = nt.oid AND (t.relkind = ANY (ARRAY['r'::""char"", 'v'::""char"", 'f'::""char"", 'p'::""char""])) AND t.oid = a.attrelid AND dt.refobjsubid = a.attnum AND pg_has_role(t.relowner, 'USAGE'::text);"
information_schema	view_routine_usage		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	6	0	" SELECT DISTINCT current_database()::information_schema.sql_identifier AS table_catalog,\n    nv.nspname::information_schema.sql_identifier AS table_schema,\n    v.relname::information_schema.sql_identifier AS table_name,\n    current_database()::information_schema.sql_identifier AS specific_catalog,\n    np.nspname::information_schema.sql_identifier AS specific_schema,\n    nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name\n   FROM pg_namespace nv,\n    pg_class v,\n    pg_depend dv,\n    pg_depend dp,\n    pg_proc p,\n    pg_namespace np\n  WHERE nv.oid = v.relnamespace AND v.relkind = 'v'::""char"" AND v.oid = dv.refobjid AND dv.refclassid = 'pg_class'::regclass::oid AND dv.classid = 'pg_rewrite'::regclass::oid AND dv.deptype = 'i'::""char"" AND dv.objid = dp.objid AND dp.classid = 'pg_rewrite'::regclass::oid AND dp.refclassid = 'pg_proc'::regclass::oid AND dp.refobjid = p.oid AND p.pronamespace = np.oid AND pg_has_role(p.proowner, 'USAGE'::text);"
information_schema	view_table_usage		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	6	0	" SELECT DISTINCT current_database()::information_schema.sql_identifier AS view_catalog,\n    nv.nspname::information_schema.sql_identifier AS view_schema,\n    v.relname::information_schema.sql_identifier AS view_name,\n    current_database()::information_schema.sql_identifier AS table_catalog,\n    nt.nspname::information_schema.sql_identifier AS table_schema,\n    t.relname::information_schema.sql_identifier AS table_name\n   FROM pg_namespace nv,\n    pg_class v,\n    pg_depend dv,\n    pg_depend dt,\n    pg_class t,\n    pg_namespace nt\n  WHERE nv.oid = v.relnamespace AND v.relkind = 'v'::""char"" AND v.oid = dv.refobjid AND dv.refclassid = 'pg_class'::regclass::oid AND dv.classid = 'pg_rewrite'::regclass::oid AND dv.deptype = 'i'::""char"" AND dv.objid = dt.objid AND dv.refobjid <> dt.refobjid AND dt.classid = 'pg_rewrite'::regclass::oid AND dt.refclassid = 'pg_class'::regclass::oid AND dt.refobjid = t.oid AND t.relnamespace = nt.oid AND (t.relkind = ANY (ARRAY['r'::""char"", 'v'::""char"", 'f'::""char"", 'p'::""char""])) AND pg_has_role(t.relowner, 'USAGE'::text);"
information_schema	views		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	10	0	" SELECT current_database()::information_schema.sql_identifier AS table_catalog,\n    nc.nspname::information_schema.sql_identifier AS table_schema,\n    c.relname::information_schema.sql_identifier AS table_name,\n        CASE\n            WHEN pg_has_role(c.relowner, 'USAGE'::text) THEN pg_get_viewdef(c.oid)\n            ELSE NULL::text\n        END::information_schema.character_data AS view_definition,\n        CASE\n            WHEN 'check_option=cascaded'::text = ANY (c.reloptions) THEN 'CASCADED'::text\n            WHEN 'check_option=local'::text = ANY (c.reloptions) THEN 'LOCAL'::text\n            ELSE 'NONE'::text\n        END::information_schema.character_data AS check_option,\n        CASE\n            WHEN (pg_relation_is_updatable(c.oid::regclass, false) & 20) = 20 THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_updatable,\n        CASE\n            WHEN (pg_relation_is_updatable(c.oid::regclass, false) & 8) = 8 THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_insertable_into,\n        CASE\n            WHEN (EXISTS ( SELECT 1\n               FROM pg_trigger\n              WHERE pg_trigger.tgrelid = c.oid AND (pg_trigger.tgtype::integer & 81) = 81)) THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_trigger_updatable,\n        CASE\n            WHEN (EXISTS ( SELECT 1\n               FROM pg_trigger\n              WHERE pg_trigger.tgrelid = c.oid AND (pg_trigger.tgtype::integer & 73) = 73)) THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_trigger_deletable,\n        CASE\n            WHEN (EXISTS ( SELECT 1\n               FROM pg_trigger\n              WHERE pg_trigger.tgrelid = c.oid AND (pg_trigger.tgtype::integer & 69) = 69)) THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_trigger_insertable_into\n   FROM pg_namespace nc,\n    pg_class c\n  WHERE c.relnamespace = nc.oid AND c.relkind = 'v'::""char"" AND NOT pg_is_other_temp_schema(nc.oid) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text));"
pg_catalog	pg_available_extension_versions		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	9	0	" SELECT e.name,\n    e.version,\n    x.extname IS NOT NULL AS installed,\n    e.superuser,\n    e.trusted,\n    e.relocatable,\n    e.schema,\n    e.requires,\n    e.comment\n   FROM pg_available_extension_versions() e(name, version, superuser, trusted, relocatable, schema, requires, comment)\n     LEFT JOIN pg_extension x ON e.name = x.extname AND e.version = x.extversion;"
pg_catalog	pg_available_extensions		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	4	0	" SELECT e.name,\n    e.default_version,\n    x.extversion AS installed_version,\n    e.comment\n   FROM pg_available_extensions() e(name, default_version, comment)\n     LEFT JOIN pg_extension x ON e.name = x.extname;"
pg_catalog	pg_backend_memory_contexts		postgres	{postgres=arwdDxt/postgres}		3328	v	-1		0	0	9	0	" SELECT pg_get_backend_memory_contexts.name,\n    pg_get_backend_memory_contexts.ident,\n    pg_get_backend_memory_contexts.parent,\n    pg_get_backend_memory_contexts.level,\n    pg_get_backend_memory_contexts.total_bytes,\n    pg_get_backend_memory_contexts.total_nblocks,\n    pg_get_backend_memory_contexts.free_bytes,\n    pg_get_backend_memory_contexts.free_chunks,\n    pg_get_backend_memory_contexts.used_bytes\n   FROM pg_get_backend_memory_contexts() pg_get_backend_memory_contexts(name, ident, parent, level, total_bytes, total_nblocks, free_bytes, free_chunks, used_bytes);"
pg_catalog	pg_config		postgres	{postgres=arwdDxt/postgres}		3328	v	-1		0	0	2	0	" SELECT pg_config.name,\n    pg_config.setting\n   FROM pg_config() pg_config(name, setting);"
pg_catalog	pg_cursors		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	6	0	" SELECT c.name,\n    c.statement,\n    c.is_holdable,\n    c.is_binary,\n    c.is_scrollable,\n    c.creation_time\n   FROM pg_cursor() c(name, statement, is_holdable, is_binary, is_scrollable, creation_time);"
pg_catalog	pg_file_settings		postgres	{postgres=arwdDxt/postgres}		3328	v	-1		0	0	7	0	" SELECT a.sourcefile,\n    a.sourceline,\n    a.seqno,\n    a.name,\n    a.setting,\n    a.applied,\n    a.error\n   FROM pg_show_all_file_settings() a(sourcefile, sourceline, seqno, name, setting, applied, error);"
pg_catalog	pg_group		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	3	0	" SELECT pg_authid.rolname AS groname,\n    pg_authid.oid AS grosysid,\n    ARRAY( SELECT pg_auth_members.member\n           FROM pg_auth_members\n          WHERE pg_auth_members.roleid = pg_authid.oid) AS grolist\n   FROM pg_authid\n  WHERE NOT pg_authid.rolcanlogin;"
pg_catalog	pg_hba_file_rules		postgres	{postgres=arwdDxt/postgres}		3328	v	-1		0	0	9	0	" SELECT a.line_number,\n    a.type,\n    a.database,\n    a.user_name,\n    a.address,\n    a.netmask,\n    a.auth_method,\n    a.options,\n    a.error\n   FROM pg_hba_file_rules() a(line_number, type, database, user_name, address, netmask, auth_method, options, error);"
pg_catalog	pg_indexes		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	5	0	" SELECT n.nspname AS schemaname,\n    c.relname AS tablename,\n    i.relname AS indexname,\n    t.spcname AS tablespace,\n    pg_get_indexdef(i.oid) AS indexdef\n   FROM pg_index x\n     JOIN pg_class c ON c.oid = x.indrelid\n     JOIN pg_class i ON i.oid = x.indexrelid\n     LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\n     LEFT JOIN pg_tablespace t ON t.oid = i.reltablespace\n  WHERE (c.relkind = ANY (ARRAY['r'::""char"", 'm'::""char"", 'p'::""char""])) AND (i.relkind = ANY (ARRAY['i'::""char"", 'I'::""char""]));"
pg_catalog	pg_locks		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	16	0	" SELECT l.locktype,\n    l.database,\n    l.relation,\n    l.page,\n    l.tuple,\n    l.virtualxid,\n    l.transactionid,\n    l.classid,\n    l.objid,\n    l.objsubid,\n    l.virtualtransaction,\n    l.pid,\n    l.mode,\n    l.granted,\n    l.fastpath,\n    l.waitstart\n   FROM pg_lock_status() l(locktype, database, relation, page, tuple, virtualxid, transactionid, classid, objid, objsubid, virtualtransaction, pid, mode, granted, fastpath, waitstart);"
pg_catalog	pg_matviews		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	7	0	" SELECT n.nspname AS schemaname,\n    c.relname AS matviewname,\n    pg_get_userbyid(c.relowner) AS matviewowner,\n    t.spcname AS tablespace,\n    c.relhasindex AS hasindexes,\n    c.relispopulated AS ispopulated,\n    pg_get_viewdef(c.oid) AS definition\n   FROM pg_class c\n     LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\n     LEFT JOIN pg_tablespace t ON t.oid = c.reltablespace\n  WHERE c.relkind = 'm'::""char"";"
pg_catalog	pg_policies		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	8	0	" SELECT n.nspname AS schemaname,\n    c.relname AS tablename,\n    pol.polname AS policyname,\n        CASE\n            WHEN pol.polpermissive THEN 'PERMISSIVE'::text\n            ELSE 'RESTRICTIVE'::text\n        END AS permissive,\n        CASE\n            WHEN pol.polroles = '{0}'::oid[] THEN string_to_array('public'::text, ''::text)::name[]\n            ELSE ARRAY( SELECT pg_authid.rolname\n               FROM pg_authid\n              WHERE pg_authid.oid = ANY (pol.polroles)\n              ORDER BY pg_authid.rolname)\n        END AS roles,\n        CASE pol.polcmd\n            WHEN 'r'::""char"" THEN 'SELECT'::text\n            WHEN 'a'::""char"" THEN 'INSERT'::text\n            WHEN 'w'::""char"" THEN 'UPDATE'::text\n            WHEN 'd'::""char"" THEN 'DELETE'::text\n            WHEN '*'::""char"" THEN 'ALL'::text\n            ELSE NULL::text\n        END AS cmd,\n    pg_get_expr(pol.polqual, pol.polrelid) AS qual,\n    pg_get_expr(pol.polwithcheck, pol.polrelid) AS with_check\n   FROM pg_policy pol\n     JOIN pg_class c ON c.oid = pol.polrelid\n     LEFT JOIN pg_namespace n ON n.oid = c.relnamespace;"
pg_catalog	pg_prepared_statements		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	7	0	" SELECT p.name,\n    p.statement,\n    p.prepare_time,\n    p.parameter_types,\n    p.from_sql,\n    p.generic_plans,\n    p.custom_plans\n   FROM pg_prepared_statement() p(name, statement, prepare_time, parameter_types, from_sql, generic_plans, custom_plans);"
pg_catalog	pg_prepared_xacts		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	5	0	" SELECT p.transaction,\n    p.gid,\n    p.prepared,\n    u.rolname AS owner,\n    d.datname AS database\n   FROM pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid)\n     LEFT JOIN pg_authid u ON p.ownerid = u.oid\n     LEFT JOIN pg_database d ON p.dbid = d.oid;"
pg_catalog	pg_publication_tables		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	3	0	" SELECT p.pubname,\n    n.nspname AS schemaname,\n    c.relname AS tablename\n   FROM pg_publication p,\n    LATERAL pg_get_publication_tables(p.pubname::text) gpt(relid),\n    pg_class c\n     JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.oid = gpt.relid;"
pg_catalog	pg_replication_origin_status		postgres	{postgres=arwdDxt/postgres}		3328	v	-1		0	0	4	0	" SELECT pg_show_replication_origin_status.local_id,\n    pg_show_replication_origin_status.external_id,\n    pg_show_replication_origin_status.remote_lsn,\n    pg_show_replication_origin_status.local_lsn\n   FROM pg_show_replication_origin_status() pg_show_replication_origin_status(local_id, external_id, remote_lsn, local_lsn);"
pg_catalog	pg_replication_slots		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	15	0	" SELECT l.slot_name,\n    l.plugin,\n    l.slot_type,\n    l.datoid,\n    d.datname AS database,\n    l.temporary,\n    l.active,\n    l.active_pid,\n    l.xmin,\n    l.catalog_xmin,\n    l.restart_lsn,\n    l.confirmed_flush_lsn,\n    l.wal_status,\n    l.safe_wal_size,\n    l.two_phase\n   FROM pg_get_replication_slots() l(slot_name, plugin, slot_type, datoid, temporary, active, active_pid, xmin, catalog_xmin, restart_lsn, confirmed_flush_lsn, wal_status, safe_wal_size, two_phase)\n     LEFT JOIN pg_database d ON l.datoid = d.oid;"
pg_catalog	pg_roles		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	13	0	" SELECT pg_authid.rolname,\n    pg_authid.rolsuper,\n    pg_authid.rolinherit,\n    pg_authid.rolcreaterole,\n    pg_authid.rolcreatedb,\n    pg_authid.rolcanlogin,\n    pg_authid.rolreplication,\n    pg_authid.rolconnlimit,\n    '********'::text AS rolpassword,\n    pg_authid.rolvaliduntil,\n    pg_authid.rolbypassrls,\n    s.setconfig AS rolconfig,\n    pg_authid.oid\n   FROM pg_authid\n     LEFT JOIN pg_db_role_setting s ON pg_authid.oid = s.setrole AND s.setdatabase = 0::oid;"
pg_catalog	pg_rules		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	4	0	" SELECT n.nspname AS schemaname,\n    c.relname AS tablename,\n    r.rulename,\n    pg_get_ruledef(r.oid) AS definition\n   FROM pg_rewrite r\n     JOIN pg_class c ON c.oid = r.ev_class\n     LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE r.rulename <> '_RETURN'::name;"
pg_catalog	pg_seclabels		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	8	0	" SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n        CASE\n            WHEN rel.relkind = ANY (ARRAY['r'::""char"", 'p'::""char""]) THEN 'table'::text\n            WHEN rel.relkind = 'v'::""char"" THEN 'view'::text\n            WHEN rel.relkind = 'm'::""char"" THEN 'materialized view'::text\n            WHEN rel.relkind = 'S'::""char"" THEN 'sequence'::text\n            WHEN rel.relkind = 'f'::""char"" THEN 'foreign table'::text\n            ELSE NULL::text\n        END AS objtype,\n    rel.relnamespace AS objnamespace,\n        CASE\n            WHEN pg_table_is_visible(rel.oid) THEN quote_ident(rel.relname::text)\n            ELSE (quote_ident(nsp.nspname::text) || '.'::text) || quote_ident(rel.relname::text)\n        END AS objname,\n    l.provider,\n    l.label\n   FROM pg_seclabel l\n     JOIN pg_class rel ON l.classoid = rel.tableoid AND l.objoid = rel.oid\n     JOIN pg_namespace nsp ON rel.relnamespace = nsp.oid\n  WHERE l.objsubid = 0\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n    'column'::text AS objtype,\n    rel.relnamespace AS objnamespace,\n    (\n        CASE\n            WHEN pg_table_is_visible(rel.oid) THEN quote_ident(rel.relname::text)\n            ELSE (quote_ident(nsp.nspname::text) || '.'::text) || quote_ident(rel.relname::text)\n        END || '.'::text) || att.attname::text AS objname,\n    l.provider,\n    l.label\n   FROM pg_seclabel l\n     JOIN pg_class rel ON l.classoid = rel.tableoid AND l.objoid = rel.oid\n     JOIN pg_attribute att ON rel.oid = att.attrelid AND l.objsubid = att.attnum\n     JOIN pg_namespace nsp ON rel.relnamespace = nsp.oid\n  WHERE l.objsubid <> 0\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n        CASE pro.prokind\n            WHEN 'a'::""char"" THEN 'aggregate'::text\n            WHEN 'f'::""char"" THEN 'function'::text\n            WHEN 'p'::""char"" THEN 'procedure'::text\n            WHEN 'w'::""char"" THEN 'window'::text\n            ELSE NULL::text\n        END AS objtype,\n    pro.pronamespace AS objnamespace,\n    ((\n        CASE\n            WHEN pg_function_is_visible(pro.oid) THEN quote_ident(pro.proname::text)\n            ELSE (quote_ident(nsp.nspname::text) || '.'::text) || quote_ident(pro.proname::text)\n        END || '('::text) || pg_get_function_arguments(pro.oid)) || ')'::text AS objname,\n    l.provider,\n    l.label\n   FROM pg_seclabel l\n     JOIN pg_proc pro ON l.classoid = pro.tableoid AND l.objoid = pro.oid\n     JOIN pg_namespace nsp ON pro.pronamespace = nsp.oid\n  WHERE l.objsubid = 0\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n        CASE\n            WHEN typ.typtype = 'd'::""char"" THEN 'domain'::text\n            ELSE 'type'::text\n        END AS objtype,\n    typ.typnamespace AS objnamespace,\n        CASE\n            WHEN pg_type_is_visible(typ.oid) THEN quote_ident(typ.typname::text)\n            ELSE (quote_ident(nsp.nspname::text) || '.'::text) || quote_ident(typ.typname::text)\n        END AS objname,\n    l.provider,\n    l.label\n   FROM pg_seclabel l\n     JOIN pg_type typ ON l.classoid = typ.tableoid AND l.objoid = typ.oid\n     JOIN pg_namespace nsp ON typ.typnamespace = nsp.oid\n  WHERE l.objsubid = 0\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n    'large object'::text AS objtype,\n    NULL::oid AS objnamespace,\n    l.objoid::text AS objname,\n    l.provider,\n    l.label\n   FROM pg_seclabel l\n     JOIN pg_largeobject_metadata lom ON l.objoid = lom.oid\n  WHERE l.classoid = 'pg_largeobject'::regclass::oid AND l.objsubid = 0\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n    'language'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident(lan.lanname::text) AS objname,\n    l.provider,\n    l.label\n   FROM pg_seclabel l\n     JOIN pg_language lan ON l.classoid = lan.tableoid AND l.objoid = lan.oid\n  WHERE l.objsubid = 0\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n    'schema'::text AS objtype,\n    nsp.oid AS objnamespace,\n    quote_ident(nsp.nspname::text) AS objname,\n    l.provider,\n    l.label\n   FROM pg_seclabel l\n     JOIN pg_namespace nsp ON l.classoid = nsp.tableoid AND l.objoid = nsp.oid\n  WHERE l.objsubid = 0\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n    'event trigger'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident(evt.evtname::text) AS objname,\n    l.provider,\n    l.label\n   FROM pg_seclabel l\n     JOIN pg_event_trigger evt ON l.classoid = evt.tableoid AND l.objoid = evt.oid\n  WHERE l.objsubid = 0\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n    'publication'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident(p.pubname::text) AS objname,\n    l.provider,\n    l.label\n   FROM pg_seclabel l\n     JOIN pg_publication p ON l.classoid = p.tableoid AND l.objoid = p.oid\n  WHERE l.objsubid = 0\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    0 AS objsubid,\n    'subscription'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident(s.subname::text) AS objname,\n    l.provider,\n    l.label\n   FROM pg_shseclabel l\n     JOIN pg_subscription s ON l.classoid = s.tableoid AND l.objoid = s.oid\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    0 AS objsubid,\n    'database'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident(dat.datname::text) AS objname,\n    l.provider,\n    l.label\n   FROM pg_shseclabel l\n     JOIN pg_database dat ON l.classoid = dat.tableoid AND l.objoid = dat.oid\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    0 AS objsubid,\n    'tablespace'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident(spc.spcname::text) AS objname,\n    l.provider,\n    l.label\n   FROM pg_shseclabel l\n     JOIN pg_tablespace spc ON l.classoid = spc.tableoid AND l.objoid = spc.oid\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    0 AS objsubid,\n    'role'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident(rol.rolname::text) AS objname,\n    l.provider,\n    l.label\n   FROM pg_shseclabel l\n     JOIN pg_authid rol ON l.classoid = rol.tableoid AND l.objoid = rol.oid;"
pg_catalog	pg_sequences		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	11	0	" SELECT n.nspname AS schemaname,\n    c.relname AS sequencename,\n    pg_get_userbyid(c.relowner) AS sequenceowner,\n    s.seqtypid::regtype AS data_type,\n    s.seqstart AS start_value,\n    s.seqmin AS min_value,\n    s.seqmax AS max_value,\n    s.seqincrement AS increment_by,\n    s.seqcycle AS cycle,\n    s.seqcache AS cache_size,\n        CASE\n            WHEN has_sequence_privilege(c.oid, 'SELECT,USAGE'::text) THEN pg_sequence_last_value(c.oid::regclass)\n            ELSE NULL::bigint\n        END AS last_value\n   FROM pg_sequence s\n     JOIN pg_class c ON c.oid = s.seqrelid\n     LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE NOT pg_is_other_temp_schema(n.oid) AND c.relkind = 'S'::""char"";"
pg_catalog	pg_settings		postgres	{postgres=arwdDxt/postgres,=rw/postgres}		3328	v	-1		0	0	17	0	" SELECT a.name,\n    a.setting,\n    a.unit,\n    a.category,\n    a.short_desc,\n    a.extra_desc,\n    a.context,\n    a.vartype,\n    a.source,\n    a.min_val,\n    a.max_val,\n    a.enumvals,\n    a.boot_val,\n    a.reset_val,\n    a.sourcefile,\n    a.sourceline,\n    a.pending_restart\n   FROM pg_show_all_settings() a(name, setting, unit, category, short_desc, extra_desc, context, vartype, source, min_val, max_val, enumvals, boot_val, reset_val, sourcefile, sourceline, pending_restart);"
pg_catalog	pg_shadow		postgres	{postgres=arwdDxt/postgres}		3328	v	-1		0	0	9	0	" SELECT pg_authid.rolname AS usename,\n    pg_authid.oid AS usesysid,\n    pg_authid.rolcreatedb AS usecreatedb,\n    pg_authid.rolsuper AS usesuper,\n    pg_authid.rolreplication AS userepl,\n    pg_authid.rolbypassrls AS usebypassrls,\n    pg_authid.rolpassword AS passwd,\n    pg_authid.rolvaliduntil AS valuntil,\n    s.setconfig AS useconfig\n   FROM pg_authid\n     LEFT JOIN pg_db_role_setting s ON pg_authid.oid = s.setrole AND s.setdatabase = 0::oid\n  WHERE pg_authid.rolcanlogin;"
pg_catalog	pg_shmem_allocations		postgres	{postgres=arwdDxt/postgres}		3328	v	-1		0	0	4	0	" SELECT pg_get_shmem_allocations.name,\n    pg_get_shmem_allocations.off,\n    pg_get_shmem_allocations.size,\n    pg_get_shmem_allocations.allocated_size\n   FROM pg_get_shmem_allocations() pg_get_shmem_allocations(name, off, size, allocated_size);"
pg_catalog	pg_stat_activity		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	22	0	" SELECT s.datid,\n    d.datname,\n    s.pid,\n    s.leader_pid,\n    s.usesysid,\n    u.rolname AS usename,\n    s.application_name,\n    s.client_addr,\n    s.client_hostname,\n    s.client_port,\n    s.backend_start,\n    s.xact_start,\n    s.query_start,\n    s.state_change,\n    s.wait_event_type,\n    s.wait_event,\n    s.state,\n    s.backend_xid,\n    s.backend_xmin,\n    s.query_id,\n    s.query,\n    s.backend_type\n   FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type, wait_event, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin, backend_type, ssl, sslversion, sslcipher, sslbits, ssl_client_dn, ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ, gss_enc, leader_pid, query_id)\n     LEFT JOIN pg_database d ON s.datid = d.oid\n     LEFT JOIN pg_authid u ON s.usesysid = u.oid;"
pg_catalog	pg_stat_all_indexes		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	8	0	" SELECT c.oid AS relid,\n    i.oid AS indexrelid,\n    n.nspname AS schemaname,\n    c.relname,\n    i.relname AS indexrelname,\n    pg_stat_get_numscans(i.oid) AS idx_scan,\n    pg_stat_get_tuples_returned(i.oid) AS idx_tup_read,\n    pg_stat_get_tuples_fetched(i.oid) AS idx_tup_fetch\n   FROM pg_class c\n     JOIN pg_index x ON c.oid = x.indrelid\n     JOIN pg_class i ON i.oid = x.indexrelid\n     LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = ANY (ARRAY['r'::""char"", 't'::""char"", 'm'::""char""]);"
pg_catalog	pg_stat_all_tables		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	23	0	" SELECT c.oid AS relid,\n    n.nspname AS schemaname,\n    c.relname,\n    pg_stat_get_numscans(c.oid) AS seq_scan,\n    pg_stat_get_tuples_returned(c.oid) AS seq_tup_read,\n    sum(pg_stat_get_numscans(i.indexrelid))::bigint AS idx_scan,\n    sum(pg_stat_get_tuples_fetched(i.indexrelid))::bigint + pg_stat_get_tuples_fetched(c.oid) AS idx_tup_fetch,\n    pg_stat_get_tuples_inserted(c.oid) AS n_tup_ins,\n    pg_stat_get_tuples_updated(c.oid) AS n_tup_upd,\n    pg_stat_get_tuples_deleted(c.oid) AS n_tup_del,\n    pg_stat_get_tuples_hot_updated(c.oid) AS n_tup_hot_upd,\n    pg_stat_get_live_tuples(c.oid) AS n_live_tup,\n    pg_stat_get_dead_tuples(c.oid) AS n_dead_tup,\n    pg_stat_get_mod_since_analyze(c.oid) AS n_mod_since_analyze,\n    pg_stat_get_ins_since_vacuum(c.oid) AS n_ins_since_vacuum,\n    pg_stat_get_last_vacuum_time(c.oid) AS last_vacuum,\n    pg_stat_get_last_autovacuum_time(c.oid) AS last_autovacuum,\n    pg_stat_get_last_analyze_time(c.oid) AS last_analyze,\n    pg_stat_get_last_autoanalyze_time(c.oid) AS last_autoanalyze,\n    pg_stat_get_vacuum_count(c.oid) AS vacuum_count,\n    pg_stat_get_autovacuum_count(c.oid) AS autovacuum_count,\n    pg_stat_get_analyze_count(c.oid) AS analyze_count,\n    pg_stat_get_autoanalyze_count(c.oid) AS autoanalyze_count\n   FROM pg_class c\n     LEFT JOIN pg_index i ON c.oid = i.indrelid\n     LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = ANY (ARRAY['r'::""char"", 't'::""char"", 'm'::""char"", 'p'::""char""])\n  GROUP BY c.oid, n.nspname, c.relname;"
pg_catalog	pg_stat_archiver		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	7	0	" SELECT s.archived_count,\n    s.last_archived_wal,\n    s.last_archived_time,\n    s.failed_count,\n    s.last_failed_wal,\n    s.last_failed_time,\n    s.stats_reset\n   FROM pg_stat_get_archiver() s(archived_count, last_archived_wal, last_archived_time, failed_count, last_failed_wal, last_failed_time, stats_reset);"
pg_catalog	pg_stat_bgwriter		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	11	0	" SELECT pg_stat_get_bgwriter_timed_checkpoints() AS checkpoints_timed,\n    pg_stat_get_bgwriter_requested_checkpoints() AS checkpoints_req,\n    pg_stat_get_checkpoint_write_time() AS checkpoint_write_time,\n    pg_stat_get_checkpoint_sync_time() AS checkpoint_sync_time,\n    pg_stat_get_bgwriter_buf_written_checkpoints() AS buffers_checkpoint,\n    pg_stat_get_bgwriter_buf_written_clean() AS buffers_clean,\n    pg_stat_get_bgwriter_maxwritten_clean() AS maxwritten_clean,\n    pg_stat_get_buf_written_backend() AS buffers_backend,\n    pg_stat_get_buf_fsync_backend() AS buffers_backend_fsync,\n    pg_stat_get_buf_alloc() AS buffers_alloc,\n    pg_stat_get_bgwriter_stat_reset_time() AS stats_reset;"
pg_catalog	pg_stat_database		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	28	0	" SELECT d.oid AS datid,\n    d.datname,\n        CASE\n            WHEN d.oid = 0::oid THEN 0\n            ELSE pg_stat_get_db_numbackends(d.oid)\n        END AS numbackends,\n    pg_stat_get_db_xact_commit(d.oid) AS xact_commit,\n    pg_stat_get_db_xact_rollback(d.oid) AS xact_rollback,\n    pg_stat_get_db_blocks_fetched(d.oid) - pg_stat_get_db_blocks_hit(d.oid) AS blks_read,\n    pg_stat_get_db_blocks_hit(d.oid) AS blks_hit,\n    pg_stat_get_db_tuples_returned(d.oid) AS tup_returned,\n    pg_stat_get_db_tuples_fetched(d.oid) AS tup_fetched,\n    pg_stat_get_db_tuples_inserted(d.oid) AS tup_inserted,\n    pg_stat_get_db_tuples_updated(d.oid) AS tup_updated,\n    pg_stat_get_db_tuples_deleted(d.oid) AS tup_deleted,\n    pg_stat_get_db_conflict_all(d.oid) AS conflicts,\n    pg_stat_get_db_temp_files(d.oid) AS temp_files,\n    pg_stat_get_db_temp_bytes(d.oid) AS temp_bytes,\n    pg_stat_get_db_deadlocks(d.oid) AS deadlocks,\n    pg_stat_get_db_checksum_failures(d.oid) AS checksum_failures,\n    pg_stat_get_db_checksum_last_failure(d.oid) AS checksum_last_failure,\n    pg_stat_get_db_blk_read_time(d.oid) AS blk_read_time,\n    pg_stat_get_db_blk_write_time(d.oid) AS blk_write_time,\n    pg_stat_get_db_session_time(d.oid) AS session_time,\n    pg_stat_get_db_active_time(d.oid) AS active_time,\n    pg_stat_get_db_idle_in_transaction_time(d.oid) AS idle_in_transaction_time,\n    pg_stat_get_db_sessions(d.oid) AS sessions,\n    pg_stat_get_db_sessions_abandoned(d.oid) AS sessions_abandoned,\n    pg_stat_get_db_sessions_fatal(d.oid) AS sessions_fatal,\n    pg_stat_get_db_sessions_killed(d.oid) AS sessions_killed,\n    pg_stat_get_db_stat_reset_time(d.oid) AS stats_reset\n   FROM ( SELECT 0 AS oid,\n            NULL::name AS datname\n        UNION ALL\n         SELECT pg_database.oid,\n            pg_database.datname\n           FROM pg_database) d;"
pg_catalog	pg_stat_database_conflicts		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	7	0	" SELECT d.oid AS datid,\n    d.datname,\n    pg_stat_get_db_conflict_tablespace(d.oid) AS confl_tablespace,\n    pg_stat_get_db_conflict_lock(d.oid) AS confl_lock,\n    pg_stat_get_db_conflict_snapshot(d.oid) AS confl_snapshot,\n    pg_stat_get_db_conflict_bufferpin(d.oid) AS confl_bufferpin,\n    pg_stat_get_db_conflict_startup_deadlock(d.oid) AS confl_deadlock\n   FROM pg_database d;"
pg_catalog	pg_stat_gssapi		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	4	0	" SELECT s.pid,\n    s.gss_auth AS gss_authenticated,\n    s.gss_princ AS principal,\n    s.gss_enc AS encrypted\n   FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type, wait_event, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin, backend_type, ssl, sslversion, sslcipher, sslbits, ssl_client_dn, ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ, gss_enc, leader_pid, query_id)\n  WHERE s.client_port IS NOT NULL;"
pg_catalog	pg_stat_progress_analyze		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	12	0	" SELECT s.pid,\n    s.datid,\n    d.datname,\n    s.relid,\n        CASE s.param1\n            WHEN 0 THEN 'initializing'::text\n            WHEN 1 THEN 'acquiring sample rows'::text\n            WHEN 2 THEN 'acquiring inherited sample rows'::text\n            WHEN 3 THEN 'computing statistics'::text\n            WHEN 4 THEN 'computing extended statistics'::text\n            WHEN 5 THEN 'finalizing analyze'::text\n            ELSE NULL::text\n        END AS phase,\n    s.param2 AS sample_blks_total,\n    s.param3 AS sample_blks_scanned,\n    s.param4 AS ext_stats_total,\n    s.param5 AS ext_stats_computed,\n    s.param6 AS child_tables_total,\n    s.param7 AS child_tables_done,\n    s.param8::oid AS current_child_table_relid\n   FROM pg_stat_get_progress_info('ANALYZE'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13, param14, param15, param16, param17, param18, param19, param20)\n     LEFT JOIN pg_database d ON s.datid = d.oid;"
pg_catalog	pg_stat_progress_basebackup		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	6	0	" SELECT s.pid,\n        CASE s.param1\n            WHEN 0 THEN 'initializing'::text\n            WHEN 1 THEN 'waiting for checkpoint to finish'::text\n            WHEN 2 THEN 'estimating backup size'::text\n            WHEN 3 THEN 'streaming database files'::text\n            WHEN 4 THEN 'waiting for wal archiving to finish'::text\n            WHEN 5 THEN 'transferring wal files'::text\n            ELSE NULL::text\n        END AS phase,\n        CASE s.param2\n            WHEN '-1'::integer THEN NULL::bigint\n            ELSE s.param2\n        END AS backup_total,\n    s.param3 AS backup_streamed,\n    s.param4 AS tablespaces_total,\n    s.param5 AS tablespaces_streamed\n   FROM pg_stat_get_progress_info('BASEBACKUP'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13, param14, param15, param16, param17, param18, param19, param20);"
pg_catalog	pg_stat_progress_cluster		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	12	0	" SELECT s.pid,\n    s.datid,\n    d.datname,\n    s.relid,\n        CASE s.param1\n            WHEN 1 THEN 'CLUSTER'::text\n            WHEN 2 THEN 'VACUUM FULL'::text\n            ELSE NULL::text\n        END AS command,\n        CASE s.param2\n            WHEN 0 THEN 'initializing'::text\n            WHEN 1 THEN 'seq scanning heap'::text\n            WHEN 2 THEN 'index scanning heap'::text\n            WHEN 3 THEN 'sorting tuples'::text\n            WHEN 4 THEN 'writing new heap'::text\n            WHEN 5 THEN 'swapping relation files'::text\n            WHEN 6 THEN 'rebuilding index'::text\n            WHEN 7 THEN 'performing final cleanup'::text\n            ELSE NULL::text\n        END AS phase,\n    s.param3::oid AS cluster_index_relid,\n    s.param4 AS heap_tuples_scanned,\n    s.param5 AS heap_tuples_written,\n    s.param6 AS heap_blks_total,\n    s.param7 AS heap_blks_scanned,\n    s.param8 AS index_rebuild_count\n   FROM pg_stat_get_progress_info('CLUSTER'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13, param14, param15, param16, param17, param18, param19, param20)\n     LEFT JOIN pg_database d ON s.datid = d.oid;"
pg_catalog	pg_stat_progress_copy		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	10	0	" SELECT s.pid,\n    s.datid,\n    d.datname,\n    s.relid,\n        CASE s.param5\n            WHEN 1 THEN 'COPY FROM'::text\n            WHEN 2 THEN 'COPY TO'::text\n            ELSE NULL::text\n        END AS command,\n        CASE s.param6\n            WHEN 1 THEN 'FILE'::text\n            WHEN 2 THEN 'PROGRAM'::text\n            WHEN 3 THEN 'PIPE'::text\n            WHEN 4 THEN 'CALLBACK'::text\n            ELSE NULL::text\n        END AS type,\n    s.param1 AS bytes_processed,\n    s.param2 AS bytes_total,\n    s.param3 AS tuples_processed,\n    s.param4 AS tuples_excluded\n   FROM pg_stat_get_progress_info('COPY'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13, param14, param15, param16, param17, param18, param19, param20)\n     LEFT JOIN pg_database d ON s.datid = d.oid;"
pg_catalog	pg_stat_progress_create_index		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	16	0	" SELECT s.pid,\n    s.datid,\n    d.datname,\n    s.relid,\n    s.param7::oid AS index_relid,\n        CASE s.param1\n            WHEN 1 THEN 'CREATE INDEX'::text\n            WHEN 2 THEN 'CREATE INDEX CONCURRENTLY'::text\n            WHEN 3 THEN 'REINDEX'::text\n            WHEN 4 THEN 'REINDEX CONCURRENTLY'::text\n            ELSE NULL::text\n        END AS command,\n        CASE s.param10\n            WHEN 0 THEN 'initializing'::text\n            WHEN 1 THEN 'waiting for writers before build'::text\n            WHEN 2 THEN 'building index'::text || COALESCE(': '::text || pg_indexam_progress_phasename(s.param9::oid, s.param11), ''::text)\n            WHEN 3 THEN 'waiting for writers before validation'::text\n            WHEN 4 THEN 'index validation: scanning index'::text\n            WHEN 5 THEN 'index validation: sorting tuples'::text\n            WHEN 6 THEN 'index validation: scanning table'::text\n            WHEN 7 THEN 'waiting for old snapshots'::text\n            WHEN 8 THEN 'waiting for readers before marking dead'::text\n            WHEN 9 THEN 'waiting for readers before dropping'::text\n            ELSE NULL::text\n        END AS phase,\n    s.param4 AS lockers_total,\n    s.param5 AS lockers_done,\n    s.param6 AS current_locker_pid,\n    s.param16 AS blocks_total,\n    s.param17 AS blocks_done,\n    s.param12 AS tuples_total,\n    s.param13 AS tuples_done,\n    s.param14 AS partitions_total,\n    s.param15 AS partitions_done\n   FROM pg_stat_get_progress_info('CREATE INDEX'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13, param14, param15, param16, param17, param18, param19, param20)\n     LEFT JOIN pg_database d ON s.datid = d.oid;"
pg_catalog	pg_stat_progress_vacuum		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	11	0	" SELECT s.pid,\n    s.datid,\n    d.datname,\n    s.relid,\n        CASE s.param1\n            WHEN 0 THEN 'initializing'::text\n            WHEN 1 THEN 'scanning heap'::text\n            WHEN 2 THEN 'vacuuming indexes'::text\n            WHEN 3 THEN 'vacuuming heap'::text\n            WHEN 4 THEN 'cleaning up indexes'::text\n            WHEN 5 THEN 'truncating heap'::text\n            WHEN 6 THEN 'performing final cleanup'::text\n            ELSE NULL::text\n        END AS phase,\n    s.param2 AS heap_blks_total,\n    s.param3 AS heap_blks_scanned,\n    s.param4 AS heap_blks_vacuumed,\n    s.param5 AS index_vacuum_count,\n    s.param6 AS max_dead_tuples,\n    s.param7 AS num_dead_tuples\n   FROM pg_stat_get_progress_info('VACUUM'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13, param14, param15, param16, param17, param18, param19, param20)\n     LEFT JOIN pg_database d ON s.datid = d.oid;"
pg_catalog	pg_stat_replication		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	20	0	" SELECT s.pid,\n    s.usesysid,\n    u.rolname AS usename,\n    s.application_name,\n    s.client_addr,\n    s.client_hostname,\n    s.client_port,\n    s.backend_start,\n    s.backend_xmin,\n    w.state,\n    w.sent_lsn,\n    w.write_lsn,\n    w.flush_lsn,\n    w.replay_lsn,\n    w.write_lag,\n    w.flush_lag,\n    w.replay_lag,\n    w.sync_priority,\n    w.sync_state,\n    w.reply_time\n   FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type, wait_event, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin, backend_type, ssl, sslversion, sslcipher, sslbits, ssl_client_dn, ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ, gss_enc, leader_pid, query_id)\n     JOIN pg_stat_get_wal_senders() w(pid, state, sent_lsn, write_lsn, flush_lsn, replay_lsn, write_lag, flush_lag, replay_lag, sync_priority, sync_state, reply_time) ON s.pid = w.pid\n     LEFT JOIN pg_authid u ON s.usesysid = u.oid;"
pg_catalog	pg_stat_replication_slots		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	10	0	" SELECT s.slot_name,\n    s.spill_txns,\n    s.spill_count,\n    s.spill_bytes,\n    s.stream_txns,\n    s.stream_count,\n    s.stream_bytes,\n    s.total_txns,\n    s.total_bytes,\n    s.stats_reset\n   FROM pg_replication_slots r,\n    LATERAL pg_stat_get_replication_slot(r.slot_name::text) s(slot_name, spill_txns, spill_count, spill_bytes, stream_txns, stream_count, stream_bytes, total_txns, total_bytes, stats_reset)\n  WHERE r.datoid IS NOT NULL;"
pg_catalog	pg_stat_slru		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	9	0	" SELECT s.name,\n    s.blks_zeroed,\n    s.blks_hit,\n    s.blks_read,\n    s.blks_written,\n    s.blks_exists,\n    s.flushes,\n    s.truncates,\n    s.stats_reset\n   FROM pg_stat_get_slru() s(name, blks_zeroed, blks_hit, blks_read, blks_written, blks_exists, flushes, truncates, stats_reset);"
pg_catalog	pg_stat_ssl		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	8	0	" SELECT s.pid,\n    s.ssl,\n    s.sslversion AS version,\n    s.sslcipher AS cipher,\n    s.sslbits AS bits,\n    s.ssl_client_dn AS client_dn,\n    s.ssl_client_serial AS client_serial,\n    s.ssl_issuer_dn AS issuer_dn\n   FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type, wait_event, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin, backend_type, ssl, sslversion, sslcipher, sslbits, ssl_client_dn, ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ, gss_enc, leader_pid, query_id)\n  WHERE s.client_port IS NOT NULL;"
pg_catalog	pg_stat_subscription		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	9	0	" SELECT su.oid AS subid,\n    su.subname,\n    st.pid,\n    st.relid,\n    st.received_lsn,\n    st.last_msg_send_time,\n    st.last_msg_receipt_time,\n    st.latest_end_lsn,\n    st.latest_end_time\n   FROM pg_subscription su\n     LEFT JOIN pg_stat_get_subscription(NULL::oid) st(subid, relid, pid, received_lsn, last_msg_send_time, last_msg_receipt_time, latest_end_lsn, latest_end_time) ON st.subid = su.oid;"
pg_catalog	pg_stat_sys_indexes		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	8	0	" SELECT pg_stat_all_indexes.relid,\n    pg_stat_all_indexes.indexrelid,\n    pg_stat_all_indexes.schemaname,\n    pg_stat_all_indexes.relname,\n    pg_stat_all_indexes.indexrelname,\n    pg_stat_all_indexes.idx_scan,\n    pg_stat_all_indexes.idx_tup_read,\n    pg_stat_all_indexes.idx_tup_fetch\n   FROM pg_stat_all_indexes\n  WHERE (pg_stat_all_indexes.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR pg_stat_all_indexes.schemaname ~ '^pg_toast'::text;"
pg_catalog	pg_stat_sys_tables		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	23	0	" SELECT pg_stat_all_tables.relid,\n    pg_stat_all_tables.schemaname,\n    pg_stat_all_tables.relname,\n    pg_stat_all_tables.seq_scan,\n    pg_stat_all_tables.seq_tup_read,\n    pg_stat_all_tables.idx_scan,\n    pg_stat_all_tables.idx_tup_fetch,\n    pg_stat_all_tables.n_tup_ins,\n    pg_stat_all_tables.n_tup_upd,\n    pg_stat_all_tables.n_tup_del,\n    pg_stat_all_tables.n_tup_hot_upd,\n    pg_stat_all_tables.n_live_tup,\n    pg_stat_all_tables.n_dead_tup,\n    pg_stat_all_tables.n_mod_since_analyze,\n    pg_stat_all_tables.n_ins_since_vacuum,\n    pg_stat_all_tables.last_vacuum,\n    pg_stat_all_tables.last_autovacuum,\n    pg_stat_all_tables.last_analyze,\n    pg_stat_all_tables.last_autoanalyze,\n    pg_stat_all_tables.vacuum_count,\n    pg_stat_all_tables.autovacuum_count,\n    pg_stat_all_tables.analyze_count,\n    pg_stat_all_tables.autoanalyze_count\n   FROM pg_stat_all_tables\n  WHERE (pg_stat_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR pg_stat_all_tables.schemaname ~ '^pg_toast'::text;"
pg_catalog	pg_stat_user_functions		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	6	0	" SELECT p.oid AS funcid,\n    n.nspname AS schemaname,\n    p.proname AS funcname,\n    pg_stat_get_function_calls(p.oid) AS calls,\n    pg_stat_get_function_total_time(p.oid) AS total_time,\n    pg_stat_get_function_self_time(p.oid) AS self_time\n   FROM pg_proc p\n     LEFT JOIN pg_namespace n ON n.oid = p.pronamespace\n  WHERE p.prolang <> 12::oid AND pg_stat_get_function_calls(p.oid) IS NOT NULL;"
pg_catalog	pg_stat_user_indexes		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	8	0	" SELECT pg_stat_all_indexes.relid,\n    pg_stat_all_indexes.indexrelid,\n    pg_stat_all_indexes.schemaname,\n    pg_stat_all_indexes.relname,\n    pg_stat_all_indexes.indexrelname,\n    pg_stat_all_indexes.idx_scan,\n    pg_stat_all_indexes.idx_tup_read,\n    pg_stat_all_indexes.idx_tup_fetch\n   FROM pg_stat_all_indexes\n  WHERE (pg_stat_all_indexes.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND pg_stat_all_indexes.schemaname !~ '^pg_toast'::text;"
pg_catalog	pg_stat_user_tables		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	23	0	" SELECT pg_stat_all_tables.relid,\n    pg_stat_all_tables.schemaname,\n    pg_stat_all_tables.relname,\n    pg_stat_all_tables.seq_scan,\n    pg_stat_all_tables.seq_tup_read,\n    pg_stat_all_tables.idx_scan,\n    pg_stat_all_tables.idx_tup_fetch,\n    pg_stat_all_tables.n_tup_ins,\n    pg_stat_all_tables.n_tup_upd,\n    pg_stat_all_tables.n_tup_del,\n    pg_stat_all_tables.n_tup_hot_upd,\n    pg_stat_all_tables.n_live_tup,\n    pg_stat_all_tables.n_dead_tup,\n    pg_stat_all_tables.n_mod_since_analyze,\n    pg_stat_all_tables.n_ins_since_vacuum,\n    pg_stat_all_tables.last_vacuum,\n    pg_stat_all_tables.last_autovacuum,\n    pg_stat_all_tables.last_analyze,\n    pg_stat_all_tables.last_autoanalyze,\n    pg_stat_all_tables.vacuum_count,\n    pg_stat_all_tables.autovacuum_count,\n    pg_stat_all_tables.analyze_count,\n    pg_stat_all_tables.autoanalyze_count\n   FROM pg_stat_all_tables\n  WHERE (pg_stat_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND pg_stat_all_tables.schemaname !~ '^pg_toast'::text;"
pg_catalog	pg_stat_wal		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	9	0	" SELECT w.wal_records,\n    w.wal_fpi,\n    w.wal_bytes,\n    w.wal_buffers_full,\n    w.wal_write,\n    w.wal_sync,\n    w.wal_write_time,\n    w.wal_sync_time,\n    w.stats_reset\n   FROM pg_stat_get_wal() w(wal_records, wal_fpi, wal_bytes, wal_buffers_full, wal_write, wal_sync, wal_write_time, wal_sync_time, stats_reset);"
pg_catalog	pg_stat_wal_receiver		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	15	0	" SELECT s.pid,\n    s.status,\n    s.receive_start_lsn,\n    s.receive_start_tli,\n    s.written_lsn,\n    s.flushed_lsn,\n    s.received_tli,\n    s.last_msg_send_time,\n    s.last_msg_receipt_time,\n    s.latest_end_lsn,\n    s.latest_end_time,\n    s.slot_name,\n    s.sender_host,\n    s.sender_port,\n    s.conninfo\n   FROM pg_stat_get_wal_receiver() s(pid, status, receive_start_lsn, receive_start_tli, written_lsn, flushed_lsn, received_tli, last_msg_send_time, last_msg_receipt_time, latest_end_lsn, latest_end_time, slot_name, sender_host, sender_port, conninfo)\n  WHERE s.pid IS NOT NULL;"
pg_catalog	pg_stat_xact_all_tables		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	11	0	" SELECT c.oid AS relid,\n    n.nspname AS schemaname,\n    c.relname,\n    pg_stat_get_xact_numscans(c.oid) AS seq_scan,\n    pg_stat_get_xact_tuples_returned(c.oid) AS seq_tup_read,\n    sum(pg_stat_get_xact_numscans(i.indexrelid))::bigint AS idx_scan,\n    sum(pg_stat_get_xact_tuples_fetched(i.indexrelid))::bigint + pg_stat_get_xact_tuples_fetched(c.oid) AS idx_tup_fetch,\n    pg_stat_get_xact_tuples_inserted(c.oid) AS n_tup_ins,\n    pg_stat_get_xact_tuples_updated(c.oid) AS n_tup_upd,\n    pg_stat_get_xact_tuples_deleted(c.oid) AS n_tup_del,\n    pg_stat_get_xact_tuples_hot_updated(c.oid) AS n_tup_hot_upd\n   FROM pg_class c\n     LEFT JOIN pg_index i ON c.oid = i.indrelid\n     LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = ANY (ARRAY['r'::""char"", 't'::""char"", 'm'::""char"", 'p'::""char""])\n  GROUP BY c.oid, n.nspname, c.relname;"
pg_catalog	pg_stat_xact_sys_tables		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	11	0	" SELECT pg_stat_xact_all_tables.relid,\n    pg_stat_xact_all_tables.schemaname,\n    pg_stat_xact_all_tables.relname,\n    pg_stat_xact_all_tables.seq_scan,\n    pg_stat_xact_all_tables.seq_tup_read,\n    pg_stat_xact_all_tables.idx_scan,\n    pg_stat_xact_all_tables.idx_tup_fetch,\n    pg_stat_xact_all_tables.n_tup_ins,\n    pg_stat_xact_all_tables.n_tup_upd,\n    pg_stat_xact_all_tables.n_tup_del,\n    pg_stat_xact_all_tables.n_tup_hot_upd\n   FROM pg_stat_xact_all_tables\n  WHERE (pg_stat_xact_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR pg_stat_xact_all_tables.schemaname ~ '^pg_toast'::text;"
pg_catalog	pg_stat_xact_user_functions		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	6	0	" SELECT p.oid AS funcid,\n    n.nspname AS schemaname,\n    p.proname AS funcname,\n    pg_stat_get_xact_function_calls(p.oid) AS calls,\n    pg_stat_get_xact_function_total_time(p.oid) AS total_time,\n    pg_stat_get_xact_function_self_time(p.oid) AS self_time\n   FROM pg_proc p\n     LEFT JOIN pg_namespace n ON n.oid = p.pronamespace\n  WHERE p.prolang <> 12::oid AND pg_stat_get_xact_function_calls(p.oid) IS NOT NULL;"
pg_catalog	pg_stat_xact_user_tables		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	11	0	" SELECT pg_stat_xact_all_tables.relid,\n    pg_stat_xact_all_tables.schemaname,\n    pg_stat_xact_all_tables.relname,\n    pg_stat_xact_all_tables.seq_scan,\n    pg_stat_xact_all_tables.seq_tup_read,\n    pg_stat_xact_all_tables.idx_scan,\n    pg_stat_xact_all_tables.idx_tup_fetch,\n    pg_stat_xact_all_tables.n_tup_ins,\n    pg_stat_xact_all_tables.n_tup_upd,\n    pg_stat_xact_all_tables.n_tup_del,\n    pg_stat_xact_all_tables.n_tup_hot_upd\n   FROM pg_stat_xact_all_tables\n  WHERE (pg_stat_xact_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND pg_stat_xact_all_tables.schemaname !~ '^pg_toast'::text;"
pg_catalog	pg_statio_all_indexes		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	7	0	" SELECT c.oid AS relid,\n    i.oid AS indexrelid,\n    n.nspname AS schemaname,\n    c.relname,\n    i.relname AS indexrelname,\n    pg_stat_get_blocks_fetched(i.oid) - pg_stat_get_blocks_hit(i.oid) AS idx_blks_read,\n    pg_stat_get_blocks_hit(i.oid) AS idx_blks_hit\n   FROM pg_class c\n     JOIN pg_index x ON c.oid = x.indrelid\n     JOIN pg_class i ON i.oid = x.indexrelid\n     LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = ANY (ARRAY['r'::""char"", 't'::""char"", 'm'::""char""]);"
pg_catalog	pg_statio_all_sequences		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	5	0	" SELECT c.oid AS relid,\n    n.nspname AS schemaname,\n    c.relname,\n    pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid) AS blks_read,\n    pg_stat_get_blocks_hit(c.oid) AS blks_hit\n   FROM pg_class c\n     LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = 'S'::""char"";"
pg_catalog	pg_statio_all_tables		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	11	0	" SELECT c.oid AS relid,\n    n.nspname AS schemaname,\n    c.relname,\n    pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid) AS heap_blks_read,\n    pg_stat_get_blocks_hit(c.oid) AS heap_blks_hit,\n    sum(pg_stat_get_blocks_fetched(i.indexrelid) - pg_stat_get_blocks_hit(i.indexrelid))::bigint AS idx_blks_read,\n    sum(pg_stat_get_blocks_hit(i.indexrelid))::bigint AS idx_blks_hit,\n    pg_stat_get_blocks_fetched(t.oid) - pg_stat_get_blocks_hit(t.oid) AS toast_blks_read,\n    pg_stat_get_blocks_hit(t.oid) AS toast_blks_hit,\n    pg_stat_get_blocks_fetched(x.indexrelid) - pg_stat_get_blocks_hit(x.indexrelid) AS tidx_blks_read,\n    pg_stat_get_blocks_hit(x.indexrelid) AS tidx_blks_hit\n   FROM pg_class c\n     LEFT JOIN pg_index i ON c.oid = i.indrelid\n     LEFT JOIN pg_class t ON c.reltoastrelid = t.oid\n     LEFT JOIN pg_index x ON t.oid = x.indrelid\n     LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = ANY (ARRAY['r'::""char"", 't'::""char"", 'm'::""char""])\n  GROUP BY c.oid, n.nspname, c.relname, t.oid, x.indexrelid;"
pg_catalog	pg_statio_sys_indexes		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	7	0	" SELECT pg_statio_all_indexes.relid,\n    pg_statio_all_indexes.indexrelid,\n    pg_statio_all_indexes.schemaname,\n    pg_statio_all_indexes.relname,\n    pg_statio_all_indexes.indexrelname,\n    pg_statio_all_indexes.idx_blks_read,\n    pg_statio_all_indexes.idx_blks_hit\n   FROM pg_statio_all_indexes\n  WHERE (pg_statio_all_indexes.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR pg_statio_all_indexes.schemaname ~ '^pg_toast'::text;"
pg_catalog	pg_statio_sys_sequences		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	5	0	" SELECT pg_statio_all_sequences.relid,\n    pg_statio_all_sequences.schemaname,\n    pg_statio_all_sequences.relname,\n    pg_statio_all_sequences.blks_read,\n    pg_statio_all_sequences.blks_hit\n   FROM pg_statio_all_sequences\n  WHERE (pg_statio_all_sequences.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR pg_statio_all_sequences.schemaname ~ '^pg_toast'::text;"
pg_catalog	pg_statio_sys_tables		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	11	0	" SELECT pg_statio_all_tables.relid,\n    pg_statio_all_tables.schemaname,\n    pg_statio_all_tables.relname,\n    pg_statio_all_tables.heap_blks_read,\n    pg_statio_all_tables.heap_blks_hit,\n    pg_statio_all_tables.idx_blks_read,\n    pg_statio_all_tables.idx_blks_hit,\n    pg_statio_all_tables.toast_blks_read,\n    pg_statio_all_tables.toast_blks_hit,\n    pg_statio_all_tables.tidx_blks_read,\n    pg_statio_all_tables.tidx_blks_hit\n   FROM pg_statio_all_tables\n  WHERE (pg_statio_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR pg_statio_all_tables.schemaname ~ '^pg_toast'::text;"
pg_catalog	pg_statio_user_indexes		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	7	0	" SELECT pg_statio_all_indexes.relid,\n    pg_statio_all_indexes.indexrelid,\n    pg_statio_all_indexes.schemaname,\n    pg_statio_all_indexes.relname,\n    pg_statio_all_indexes.indexrelname,\n    pg_statio_all_indexes.idx_blks_read,\n    pg_statio_all_indexes.idx_blks_hit\n   FROM pg_statio_all_indexes\n  WHERE (pg_statio_all_indexes.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND pg_statio_all_indexes.schemaname !~ '^pg_toast'::text;"
pg_catalog	pg_statio_user_sequences		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	5	0	" SELECT pg_statio_all_sequences.relid,\n    pg_statio_all_sequences.schemaname,\n    pg_statio_all_sequences.relname,\n    pg_statio_all_sequences.blks_read,\n    pg_statio_all_sequences.blks_hit\n   FROM pg_statio_all_sequences\n  WHERE (pg_statio_all_sequences.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND pg_statio_all_sequences.schemaname !~ '^pg_toast'::text;"
pg_catalog	pg_statio_user_tables		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	11	0	" SELECT pg_statio_all_tables.relid,\n    pg_statio_all_tables.schemaname,\n    pg_statio_all_tables.relname,\n    pg_statio_all_tables.heap_blks_read,\n    pg_statio_all_tables.heap_blks_hit,\n    pg_statio_all_tables.idx_blks_read,\n    pg_statio_all_tables.idx_blks_hit,\n    pg_statio_all_tables.toast_blks_read,\n    pg_statio_all_tables.toast_blks_hit,\n    pg_statio_all_tables.tidx_blks_read,\n    pg_statio_all_tables.tidx_blks_hit\n   FROM pg_statio_all_tables\n  WHERE (pg_statio_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND pg_statio_all_tables.schemaname !~ '^pg_toast'::text;"
pg_catalog	pg_stats		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	14	0	" SELECT n.nspname AS schemaname,\n    c.relname AS tablename,\n    a.attname,\n    s.stainherit AS inherited,\n    s.stanullfrac AS null_frac,\n    s.stawidth AS avg_width,\n    s.stadistinct AS n_distinct,\n        CASE\n            WHEN s.stakind1 = 1 THEN s.stavalues1\n            WHEN s.stakind2 = 1 THEN s.stavalues2\n            WHEN s.stakind3 = 1 THEN s.stavalues3\n            WHEN s.stakind4 = 1 THEN s.stavalues4\n            WHEN s.stakind5 = 1 THEN s.stavalues5\n            ELSE NULL::anyarray\n        END AS most_common_vals,\n        CASE\n            WHEN s.stakind1 = 1 THEN s.stanumbers1\n            WHEN s.stakind2 = 1 THEN s.stanumbers2\n            WHEN s.stakind3 = 1 THEN s.stanumbers3\n            WHEN s.stakind4 = 1 THEN s.stanumbers4\n            WHEN s.stakind5 = 1 THEN s.stanumbers5\n            ELSE NULL::real[]\n        END AS most_common_freqs,\n        CASE\n            WHEN s.stakind1 = 2 THEN s.stavalues1\n            WHEN s.stakind2 = 2 THEN s.stavalues2\n            WHEN s.stakind3 = 2 THEN s.stavalues3\n            WHEN s.stakind4 = 2 THEN s.stavalues4\n            WHEN s.stakind5 = 2 THEN s.stavalues5\n            ELSE NULL::anyarray\n        END AS histogram_bounds,\n        CASE\n            WHEN s.stakind1 = 3 THEN s.stanumbers1[1]\n            WHEN s.stakind2 = 3 THEN s.stanumbers2[1]\n            WHEN s.stakind3 = 3 THEN s.stanumbers3[1]\n            WHEN s.stakind4 = 3 THEN s.stanumbers4[1]\n            WHEN s.stakind5 = 3 THEN s.stanumbers5[1]\n            ELSE NULL::real\n        END AS correlation,\n        CASE\n            WHEN s.stakind1 = 4 THEN s.stavalues1\n            WHEN s.stakind2 = 4 THEN s.stavalues2\n            WHEN s.stakind3 = 4 THEN s.stavalues3\n            WHEN s.stakind4 = 4 THEN s.stavalues4\n            WHEN s.stakind5 = 4 THEN s.stavalues5\n            ELSE NULL::anyarray\n        END AS most_common_elems,\n        CASE\n            WHEN s.stakind1 = 4 THEN s.stanumbers1\n            WHEN s.stakind2 = 4 THEN s.stanumbers2\n            WHEN s.stakind3 = 4 THEN s.stanumbers3\n            WHEN s.stakind4 = 4 THEN s.stanumbers4\n            WHEN s.stakind5 = 4 THEN s.stanumbers5\n            ELSE NULL::real[]\n        END AS most_common_elem_freqs,\n        CASE\n            WHEN s.stakind1 = 5 THEN s.stanumbers1\n            WHEN s.stakind2 = 5 THEN s.stanumbers2\n            WHEN s.stakind3 = 5 THEN s.stanumbers3\n            WHEN s.stakind4 = 5 THEN s.stanumbers4\n            WHEN s.stakind5 = 5 THEN s.stanumbers5\n            ELSE NULL::real[]\n        END AS elem_count_histogram\n   FROM pg_statistic s\n     JOIN pg_class c ON c.oid = s.starelid\n     JOIN pg_attribute a ON c.oid = a.attrelid AND a.attnum = s.staattnum\n     LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE NOT a.attisdropped AND has_column_privilege(c.oid, a.attnum, 'select'::text) AND (c.relrowsecurity = false OR NOT row_security_active(c.oid));"
pg_catalog	pg_stats_ext		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	14	0	" SELECT cn.nspname AS schemaname,\n    c.relname AS tablename,\n    sn.nspname AS statistics_schemaname,\n    s.stxname AS statistics_name,\n    pg_get_userbyid(s.stxowner) AS statistics_owner,\n    ( SELECT array_agg(a.attname ORDER BY a.attnum) AS array_agg\n           FROM unnest(s.stxkeys) k(k)\n             JOIN pg_attribute a ON a.attrelid = s.stxrelid AND a.attnum = k.k) AS attnames,\n    pg_get_statisticsobjdef_expressions(s.oid) AS exprs,\n    s.stxkind AS kinds,\n    sd.stxdndistinct AS n_distinct,\n    sd.stxddependencies AS dependencies,\n    m.most_common_vals,\n    m.most_common_val_nulls,\n    m.most_common_freqs,\n    m.most_common_base_freqs\n   FROM pg_statistic_ext s\n     JOIN pg_class c ON c.oid = s.stxrelid\n     JOIN pg_statistic_ext_data sd ON s.oid = sd.stxoid\n     LEFT JOIN pg_namespace cn ON cn.oid = c.relnamespace\n     LEFT JOIN pg_namespace sn ON sn.oid = s.stxnamespace\n     LEFT JOIN LATERAL ( SELECT array_agg(pg_mcv_list_items.""values"") AS most_common_vals,\n            array_agg(pg_mcv_list_items.nulls) AS most_common_val_nulls,\n            array_agg(pg_mcv_list_items.frequency) AS most_common_freqs,\n            array_agg(pg_mcv_list_items.base_frequency) AS most_common_base_freqs\n           FROM pg_mcv_list_items(sd.stxdmcv) pg_mcv_list_items(index, ""values"", nulls, frequency, base_frequency)) m ON sd.stxdmcv IS NOT NULL\n  WHERE NOT (EXISTS ( SELECT 1\n           FROM unnest(s.stxkeys) k(k)\n             JOIN pg_attribute a ON a.attrelid = s.stxrelid AND a.attnum = k.k\n          WHERE NOT has_column_privilege(c.oid, a.attnum, 'select'::text))) AND (c.relrowsecurity = false OR NOT row_security_active(c.oid));"
pg_catalog	pg_stats_ext_exprs		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	16	0	" SELECT cn.nspname AS schemaname,\n    c.relname AS tablename,\n    sn.nspname AS statistics_schemaname,\n    s.stxname AS statistics_name,\n    pg_get_userbyid(s.stxowner) AS statistics_owner,\n    stat.expr,\n    (stat.a).stanullfrac AS null_frac,\n    (stat.a).stawidth AS avg_width,\n    (stat.a).stadistinct AS n_distinct,\n        CASE\n            WHEN (stat.a).stakind1 = 1 THEN (stat.a).stavalues1\n            WHEN (stat.a).stakind2 = 1 THEN (stat.a).stavalues2\n            WHEN (stat.a).stakind3 = 1 THEN (stat.a).stavalues3\n            WHEN (stat.a).stakind4 = 1 THEN (stat.a).stavalues4\n            WHEN (stat.a).stakind5 = 1 THEN (stat.a).stavalues5\n            ELSE NULL::anyarray\n        END AS most_common_vals,\n        CASE\n            WHEN (stat.a).stakind1 = 1 THEN (stat.a).stanumbers1\n            WHEN (stat.a).stakind2 = 1 THEN (stat.a).stanumbers2\n            WHEN (stat.a).stakind3 = 1 THEN (stat.a).stanumbers3\n            WHEN (stat.a).stakind4 = 1 THEN (stat.a).stanumbers4\n            WHEN (stat.a).stakind5 = 1 THEN (stat.a).stanumbers5\n            ELSE NULL::real[]\n        END AS most_common_freqs,\n        CASE\n            WHEN (stat.a).stakind1 = 2 THEN (stat.a).stavalues1\n            WHEN (stat.a).stakind2 = 2 THEN (stat.a).stavalues2\n            WHEN (stat.a).stakind3 = 2 THEN (stat.a).stavalues3\n            WHEN (stat.a).stakind4 = 2 THEN (stat.a).stavalues4\n            WHEN (stat.a).stakind5 = 2 THEN (stat.a).stavalues5\n            ELSE NULL::anyarray\n        END AS histogram_bounds,\n        CASE\n            WHEN (stat.a).stakind1 = 3 THEN (stat.a).stanumbers1[1]\n            WHEN (stat.a).stakind2 = 3 THEN (stat.a).stanumbers2[1]\n            WHEN (stat.a).stakind3 = 3 THEN (stat.a).stanumbers3[1]\n            WHEN (stat.a).stakind4 = 3 THEN (stat.a).stanumbers4[1]\n            WHEN (stat.a).stakind5 = 3 THEN (stat.a).stanumbers5[1]\n            ELSE NULL::real\n        END AS correlation,\n        CASE\n            WHEN (stat.a).stakind1 = 4 THEN (stat.a).stavalues1\n            WHEN (stat.a).stakind2 = 4 THEN (stat.a).stavalues2\n            WHEN (stat.a).stakind3 = 4 THEN (stat.a).stavalues3\n            WHEN (stat.a).stakind4 = 4 THEN (stat.a).stavalues4\n            WHEN (stat.a).stakind5 = 4 THEN (stat.a).stavalues5\n            ELSE NULL::anyarray\n        END AS most_common_elems,\n        CASE\n            WHEN (stat.a).stakind1 = 4 THEN (stat.a).stanumbers1\n            WHEN (stat.a).stakind2 = 4 THEN (stat.a).stanumbers2\n            WHEN (stat.a).stakind3 = 4 THEN (stat.a).stanumbers3\n            WHEN (stat.a).stakind4 = 4 THEN (stat.a).stanumbers4\n            WHEN (stat.a).stakind5 = 4 THEN (stat.a).stanumbers5\n            ELSE NULL::real[]\n        END AS most_common_elem_freqs,\n        CASE\n            WHEN (stat.a).stakind1 = 5 THEN (stat.a).stanumbers1\n            WHEN (stat.a).stakind2 = 5 THEN (stat.a).stanumbers2\n            WHEN (stat.a).stakind3 = 5 THEN (stat.a).stanumbers3\n            WHEN (stat.a).stakind4 = 5 THEN (stat.a).stanumbers4\n            WHEN (stat.a).stakind5 = 5 THEN (stat.a).stanumbers5\n            ELSE NULL::real[]\n        END AS elem_count_histogram\n   FROM pg_statistic_ext s\n     JOIN pg_class c ON c.oid = s.stxrelid\n     LEFT JOIN pg_statistic_ext_data sd ON s.oid = sd.stxoid\n     LEFT JOIN pg_namespace cn ON cn.oid = c.relnamespace\n     LEFT JOIN pg_namespace sn ON sn.oid = s.stxnamespace\n     JOIN LATERAL ( SELECT unnest(pg_get_statisticsobjdef_expressions(s.oid)) AS expr,\n            unnest(sd.stxdexpr) AS a) stat ON stat.expr IS NOT NULL;"
pg_catalog	pg_tables		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	8	0	" SELECT n.nspname AS schemaname,\n    c.relname AS tablename,\n    pg_get_userbyid(c.relowner) AS tableowner,\n    t.spcname AS tablespace,\n    c.relhasindex AS hasindexes,\n    c.relhasrules AS hasrules,\n    c.relhastriggers AS hastriggers,\n    c.relrowsecurity AS rowsecurity\n   FROM pg_class c\n     LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\n     LEFT JOIN pg_tablespace t ON t.oid = c.reltablespace\n  WHERE c.relkind = ANY (ARRAY['r'::""char"", 'p'::""char""]);"
pg_catalog	pg_timezone_abbrevs		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	3	0	" SELECT pg_timezone_abbrevs.abbrev,\n    pg_timezone_abbrevs.utc_offset,\n    pg_timezone_abbrevs.is_dst\n   FROM pg_timezone_abbrevs() pg_timezone_abbrevs(abbrev, utc_offset, is_dst);"
pg_catalog	pg_timezone_names		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	4	0	" SELECT pg_timezone_names.name,\n    pg_timezone_names.abbrev,\n    pg_timezone_names.utc_offset,\n    pg_timezone_names.is_dst\n   FROM pg_timezone_names() pg_timezone_names(name, abbrev, utc_offset, is_dst);"
pg_catalog	pg_user		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	9	0	" SELECT pg_shadow.usename,\n    pg_shadow.usesysid,\n    pg_shadow.usecreatedb,\n    pg_shadow.usesuper,\n    pg_shadow.userepl,\n    pg_shadow.usebypassrls,\n    '********'::text AS passwd,\n    pg_shadow.valuntil,\n    pg_shadow.useconfig\n   FROM pg_shadow;"
pg_catalog	pg_user_mappings		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	6	0	" SELECT u.oid AS umid,\n    s.oid AS srvid,\n    s.srvname,\n    u.umuser,\n        CASE\n            WHEN u.umuser = 0::oid THEN 'public'::name\n            ELSE a.rolname\n        END AS usename,\n        CASE\n            WHEN u.umuser <> 0::oid AND a.rolname = CURRENT_USER AND (pg_has_role(s.srvowner, 'USAGE'::text) OR has_server_privilege(s.oid, 'USAGE'::text)) OR u.umuser = 0::oid AND pg_has_role(s.srvowner, 'USAGE'::text) OR ( SELECT pg_authid.rolsuper\n               FROM pg_authid\n              WHERE pg_authid.rolname = CURRENT_USER) THEN u.umoptions\n            ELSE NULL::text[]\n        END AS umoptions\n   FROM pg_user_mapping u\n     JOIN pg_foreign_server s ON u.umserver = s.oid\n     LEFT JOIN pg_authid a ON a.oid = u.umuser;"
pg_catalog	pg_views		postgres	{postgres=arwdDxt/postgres,=r/postgres}		3328	v	-1		0	0	4	0	" SELECT n.nspname AS schemaname,\n    c.relname AS viewname,\n    pg_get_userbyid(c.relowner) AS viewowner,\n    pg_get_viewdef(c.oid) AS definition\n   FROM pg_class c\n     LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = 'v'::""char"";"
